== C{plus}{plus} Nedir? Modern C{plus}{plus} Tarihçesi

C{plus}{plus}, genel amaçlı bir nesneye yönelik dildir, C dilinin bir uzantısı olarak Bjarne Stroustrup tarafından oluşturulmuş. Bu sebeple C stilinde veya nesneye yönelik stilde kodlama yapmak mümkündür. Bazı durumlarda her iki şekilde de kodlama yapılabilir ki bu hibrit bir dil olmanın etkin bir örneğidir.

C{plus}{plus}, yüksek ve düşük seviyeli dillerin özelliklerini kapsadığı için orta seviyeli bir dil olarak kabul görür. Başlangıçta adı "C with classes" olarak biliniyordu fakat 1983'te C{plus}{plus} olarak yeniden isimlendirilmiştir. C{plus}{plus}, C dilinden türetilmiştir fakat ALGOL 68, ADA, CLU, ML gibi dillerden de etkilenmiştir. C{plus}{plus}, nesne yönelimli programlamayı (Object Oriented Programming) C’nin kurallarıyla birlikte destekler. C dili ile sadece yapısal programlama yapsılabilirken C{plus}{plus} dili ile hem yapısal hem de nesne yönelimli programlar yapılabilir.C{plus}{plus}, ISO standardı haline gelmiştir. 1998'de, 2011'de, 2014'te ve son olarak 2017'de parça parça güncellenmştir. Modern C{plus}{plus}, C{plus}{plus} 11'den itibarendir. Modern C{plus}{plus}'ın normal C{plus}{plus}'a farklarına STL, istisnalar, templates. vb. örnektir.

== Taşınabilirlik, Derleme ve Bağlama

Standart C{plus}{plus} kullanılarak yazılmış her kod tüm platformlarda çalıştırılabilir. Ama her platformda tekrardan derlenmesi gerekecektir. 

Derleme işlemi programcının yazdığı kodun makine koduna çevrilmesidir. C{plus}{plus} için bu işi yapan çeşitli derleyiciler bulunmaktadır. GCC, Clang, VC{plus}{plus} vb.

=== Derleme İşlemleri

==== Ön işlemci

Koddaki ön işlemci komutlarını işler. Ön işlemci komutları # ile başlamak zorundadır.

==== Derleyici

İşlenmiş kodu alır ve object dosyalarına dönüştürür. Kod hatalarını kontrol eder. Diğer dosyalardan alınmış ifedeleri kabul eder.

==== Bağlayıcı

Object dosyalarını alır ve çalıştırılabilir dosyada birleştirir. Derleyicinin aldığı diğer dosyalardaki tüm ifadelerin varlığını kontrol eder.

Bağlama işlemi derlenen ayrı ayrı kodların tek bir dosyada birleştirilmesidir. C{plus}{plus} yazılan kodların ayrı dosyalara bölünmesine izin verir. Ama bu dosyaların headerlerle birbirine bağlanması gerekmektedir.

== C{plus}{plus} Temelleri

**C++ Program Yapısı**

[source, C++]
----
 #include <iostream>
 int main()
 {
    std::cout<<"Merhaba Dünya";
    return 0;
 }
----

* # ifadesi ile başlayan ifadeler C++'da önişlemci olarak bilinir. Bu     satır ile  iostream kütüphanesi içerisindeki fonkiyonları vs     
kullanmamızı sağlar. 
* Her C ++ programının main () olarak bilinen bir yöntemi olması   gerekir. Bilgisayarınızdaki programın yürütülmesine başladığınızda   uygulamanın giriş noktası olarak anılır. Int kısmı yöntemin dönüş türüdür. Fonksiyon adından sonraki boş parantezler (), bunun bir fonksiyon olduğunu ve herhangi bir bağımsız değişken gerektirmediğini, başka bir deyişle, değerleri iletmek için hiçbir parametrenin olmadığını gösterir.

* Bu kod, Merhaba Dünya metnini göndermek için cout adıyla bilinen bir yöntemi kullanır. Çıktı ve görüntüleme için konsola. Bu komutun std :: öneki cout'un std olarak bilinen bir ad alanının parçası olduğunu göstermenin bir yoludur. (::) Kapsam çözünürlüğü operatörü cout işlevinin std ad uzayının bir parçası olduğunu ve ona erişmek için kullanılır.

* main(), fonksiyonu int olarak tanımlanmıştır ve buradaki tanımlama fonksiyonun geri dönüşünü ifade etmektedir. return 0 ile fonskiyon çağrıldığı yere 0 olarak bir dönüş yapar. Bu kullanım main() fonskiyonunun kullanım standardıdır.

=== Yazım Biçimi

C{plus}{plus} büyük-küçük harfe duyarlı bir dildir. Örneğin integer tipinin anahtar kelimesi int'tir. Eğer bunun yerine Int veya INT yazarsanız derleyici bunu anlayamaz. 

Harf duyarlılığının yanında C{plus}{plus} dili aşağıdak özelliklere de sahiptir:

* derleyicinin kaynak kodu derlemeden önce çalıştırılacak görevleri belirten önişlemci yönergeleri 

* namespace'leri dahil etmek için kullanılan using yönergeleri

* dönüş tipi, isim ve parametrelerden oluşan fonksiyon başlığı

* fonksiyonun yaptığı işlemlerin bulunduğu fonksiyon gövdesi

* C{plus}{plus} kaynak kodu dosyasındaki ifadeler

* kodu anlaşılabilir kılmak için yorum satırları

* fonksiyon çağırıcıya geri değer döndüren return ifadeleri

* ifade gövdeleri için kullanılan süslü parantezler

C{plus}{plus} dili okunabilirliği kolaylaştırmak için whitespace kullanımına izin verir. Bir kaç istisna dışında derleyici whitespace karakterleri görmezden gelir.

=== C{plus}{plus} İfadeleri

Bir C{plus}{plus} programı fonksiyon, metot, sınıf gibi çeşitli bileşenlerden oluşur. Burada bulunan ifadeleri C{plus}{plus} kodunuzda kullanacsınız: 

* Tanımlamalar - Bunlar uygulamanızda kullanmak üzere değişken ve sabit tanımlamanızı sağlar.

* Atamalar - Bunlar değişkenlerinize değer atamanızı sağlar.

* Önişlemci Yönergeleri

* Yorum Satırları - Kodunuzun içerisinde dökümanlama yapmak için kullanılır.

* Fonksiyon Tanımlamaları 

=== C{plus}{plus}'daki Veri Tipleri

Herhangi bir dilde programlama yaparken, çeşitli bilgileri depolamak için çeşitli değişkenleri kullanma ihtiyacı duyarız. Değişkenler veri depolamak için ayrılmış hafıza alanlarıdır. Yani bir değişken oluşturduğumuzda bellekte belirli bir yer ayırmış oluruz.

Ayrılan verinin tipine göre işletim sistemi bellekte bir yer tahsis eder ve bu alanda neyin saklanabileceğine karar verir.

=== Numerik Veri Tipleri

C{plus}{plus} numerik değerleri saklamak için yapısal veri tipleri sağlar. Aşağıdaki tablo ne kadar boyutta saklandıklarını ve alabilecekleri değerleri görmek açısından önemlidir.

|====
| Type Name | Bytes | Alias | Range
| int | 4 | signed | –2,147,483,648 to 2,147,483,647
| unsigned int | 4 | unsigned | 0 to 4,294,967,295
| __int8 | 1 | char | -128 to 127
| unsigned __int8 | 1 | unsigned char | 0 to 255
| __int16 | 2 | short, short int, signed short int | –32,768 to 32,767
| unsigned __int16 | 2 | unsigned short, unsigned short int | 0 to 65,535
| __int32 | 4 | signed, signed int, int | –2,147,483,648 to 2,147,483,647
| unsigned __int32 | 4 | unsigned, unsigned int | 0 to 4,294,967,295
| __int64 | 8 | long long, signed long long | –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
| unsigned __int64 | 8 | unsigned long long | 0 to 18,446,744,073,709,551,615
| short | 2 | short int, signed short int | -32,768 to 32,767
| unsigned short | 2 | unsigned short int | 0 to 65,535
| long | 4 | long int, signed long int | –2,147,483,648 to 2,147,483,647
| unsigned long | 4 | unsigned long int | 0 to 4,294,967,295
| long long | 8 | none | –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
| unsigned long long | 8 | none | 0 to 18,446,744,073,709,551,615
| float | 4 | none | 3.4E +/- 38 (7 digits)
| double | 8 | none | 1.7E +/- 308 (15 digits)
| long double | 8 | none | 1.7E +/- 308 (15 digits)
|====

=== Karakter Veri

Karakter veri harf ve semboller gibi numerik olmayan verileri göstermek için kullanılır.

|====
| **Type Name** | **Bytes** | **Alias** | **Range**
| char | 1 | none | –128 to 127 by default 0 to 255 when compiled by using /J
| signed char | 1 | none | -128 to 127
| unsigned char | 1 | none | 0 to 255
| wchar_t, char16_t, and char32_t | 2 or 4 | __wchar_t | 0 to 65,535 (wchar_t & char16_t), 0 to 4,294,967,295 (char32_t)
|====

=== Typedef Tanımlaması

Typedef tanımlaması veri türlerini temsil eden kelimeleri farklı şekilde tanımlamayı sağlar. Bu şekilde mevcut bir veri türü için yeni bir isim veya yeni bir veri türü oluşturulabilir. typedef ifadesinin genel yapısı aşağıdaki şekildedir:

[source, c++]
----
typedef eskiIsim yeniIsim;
----

Yukarıdaki işlem sayesinde eskiIsim tipinde bir veri tanımlarken yeniIsim adını da kullanabilirsiniz. 
Örnek olarak:

[source,c++]
----
using namespace std;

int main() {
    typedef int sayi;

    sayi x = 5;
    cout << "sayi tipindeki x degiskeninin degeri: " <<x << endl;

    return 0;
}

----

Bu örnekte typedef ile int veri tipi ismi yerine sayi isminin de kullanılmasına izin verilmiştir. Örneğin çıktısı şu şekilde olacaktır: 

----
sayi tipindeki x degiskeninin degeri: 5
----

typedef ifadesi kullanılarak oluşturulan veri tipi ismini başka bir veri tipi ismine izin vermek için kullanmak herhangi bir hataya sebebiyet vermez, örnek vermek gerekirse: 

[source,c++]
----
using namespace std;

int main() {
    typedef int a;
    typedef a b;

    int sayi1;
    a sayi2;
    b sayi3;

    sayi1 = 3;
    sayi2 = 1;
    sayi3 = 24;

    cout << "sayi1: " << sayi1 << ", sayi2: " << sayi2 << ", sayi3: " << sayi3 << endl;
}

----

Bu örnekte typedef ile int veri tipine alternatif bir isim olarak 'a' ismi veriliyor sonra da 'a' tipine alternatif olarak 'b' ismi veriliyor yani bir nevi zincirleme yapılması mümkündür denilebilir. Örneğin çıktısı şu şekilde olacaktır.

----
sayi1: 3, sayi2: 1, sayi3: 24
----

== Değişkenler ve Sabitler

Değişkenler kodunuzda değer tutan veya referans gösteren tanımlayıcılardır. Değişken tam olarak isimli hafıza alanıdır denilebilir.

Bazı programlama dilleri gerektiğinde veri tipi göstermeden değişken tanımlamaya izin vermektedir. Fakat C{plus}{plus} böyle bir mekanizmaya sahip değildir, bir değişkeni kullanmak için öncesinde tanımlanması gereklidir. Değişken tanımlarken uyulması gereken bir kaç kural vardır: 

* Büyük ya da küçük İngilizce karakter veya '_' ile başlayabilir. Rakam ile başlayamaz.

* main, case, class, if, else, do, while, for, typedef gibi C{plus}{plus} anahtar kelimeleri değişken ismi olarak kullanılamaz.

* Tanım alanı içerisinde tek olmalıdır.

Uzunluk konusunda kısıtlama yoktur. C{plus}{plus} büyük-küçük harfe duyarlı bir dildir.

Aşağıdaki iki şekilde değişken tanımlanabilir:

[source, c++]
----
int degisken = 0;
int degisken2 {1};
----

=== Değişken Türleri

Temel olarak iki tür değişken vardır:

* Bir fonksiyon veya blok içerisindeki yerel değişkenler
* Tüm fonksiyonların dışında bulunan global değişkenler

==== Yerel Değişken
Bir fonksiyon veya blok içerisinde tanımlanan değişkenler yerel değişkenlerdir. Sadece içinde bulundukları fonksiyon veya bloğun içerisinde kullanılabilirler. Örnek olarak:

[source,c++]
----
using namespace std;

int main () {
   int a, b, c; // Yerel Değişken

   a = 10;
   b = 20;
   c = a + b;

   cout << c;

   return 0;
}
----

Çıktı:

----
30
----

==== Global Değişken
Global değişkenler tüm fonksiyonların dışında, genellikle programın en üst kısmında tanımlanır. Değerlerini program çalıştığı sürece tutarlar. Örnek olarak: 

[source,c++]
----
using namespace std;

int x = 10;///Global değişken

int main() {
    if(true) {
        int x = 3;///İf bloğunun yerel değişkeni
        cout << "If blogu icerisindeki x degeri: " << x << endl;
    }
    cout << "If blogu disindaki x degeri: "<< x << endl;
}

----

Yukarıdaki örnekte global olarak bir x değişkeni tanımlanmış olmasına rağmen if bloğunun içerisinde orada tanımlanmış yerel x değişkenine öncelik verilir. Çıktı aşağıdaki gibi olacaktır: 

----
If blogu icerisindeki x degeri: 3
If blogu disindaki x degeri: 10
----

=== Global ve Yerel Değişken Varsayılan Tanımlayıcıları

Yerel değişkenler tanımlandığında kullanıcı tarafından bir değer atanması zorunludur fakat global değişkenler tanımlandığında sistem otomatik olarak bir değer atar. Bu değerler aşağıdaki gibidir: 

[width="40%",frame="topbot",options="header,footer"]
|======================
|Veri Tipi  |Tanımlayıcı  
|int        |0
|char       |'\0'
|float      |0
|double     |0
|pointer    |NULL
|======================

=== Sabitler

Sabitler program tarafından değiştirilemeyen değerlerdir ve literal olarak adlandırılırlar.

Sabitler herhangi bir temel veri tipinde olabilirler ve herhangi biriyle işleme girebilirler.

Sabitlerin normal değişkenlerden tek farkı değiştirilemez olmalarıdır.

=== Literaller

==== İnteger Literal

İnteger bir literal onluk, onaltılık veya sekizlik tabanda bir sabit olabilir. Tabanını aldığı ön ek belirler: 0x - Onaltılık, 0 - Sekizlik, Boş - Onluk

İnteger bir literal aynı zamanda U ve L son eklerini de alabilir ki bunlar unsigned ve long anlamına gelmektedirler. Son ek küçük-büyük harfe duyarlı değildir.

İnteger literaller ile ilgili bir kaç örnek:

----
123     //Doğru
1234u   //Doğru
0x888   //Doğru
038     // Yanlış: Sekizlik sistemde 8 rakamı bulunamaz
25uu    // Yanlış: Son ek tekrarlanamaz
----

==== Boolean Literal
Standart C{plus}{plus}'a ait iki boolean literal vardır:

* true değeri doğruyu temsil eder.
* false değeri yanlışı temsil eder

==== Karakter Literal
Karakter literaller tek tırnak içerisinde gösterilir. Eğer literal L harfiyle başlıyorsa geniş karakter literaldir (örnek: L'x') ve wchar_t tipinde bir değişkende saklanmalıdır. 

Bir karakter literal bir harften, escape sequence'den veya evrensel bir karakterden(örnek: '\u02C0') oluşabilir. 

[width="40%",frame="topbot",options="header,footer"]
|====
| Escape sequence | Meaning
| \\ | \ character
| \' | ' character
| \" | " character
| \? | ? character
| \a | Alert or bell
| \b | Backspace
| \f | Form feed
| \n | Newline
| \r | Carriage return
| \t | Horizontal tab
| \v | Vertical tab
| \ooo | Octal number of one to three digits
| \xhh . . . | Hexadecimal number of one or more digits
|====

Örnek olarak: 

[source,c++]
----
using namespace std;

int main() {
   cout << "Hello\tWorld\n\n";
   return 0;
}
----

Çıktı: 

----
Hello   World
----

==== String Literal
String literaller çift tırnak içerisinde gösterilir. Özellik olarak karakter literallere benzerler. Harf, escape sequence veya evrensel karakter barındırabilirler. Örnek olarak: 


----
"merhaba, dünya"

"merhaba, \

dünya"

"merhaba, " "d" "ünya"
----

=== Sabit Tanımlama
C{plus}{plus}'da sabit tanımlamanın iki yolu vardır: 

* #define kullanmak
* const anahtar kelimesini kullanmak

==== #define
[source, c++]
----
#define PI  3.14;
using namespace std;

int main(){
    cout<<PI;
    return 0;
}
----

Çıktı:

----
3.14
----

==== const
[source,c++]
----
using namespace std;

int main(){
    const int UZUNLUK = 20;
    const int GENISLIK = 5;
    const int ALAN = UZUNLUK*GENISLIK;

    cout << "Alan: " <<  ALAN << endl;

    return 0;
}
----

Çıktı:

----
Alan: 100
----

=== Karmaşık Veri Tipleri

C{plus}{plus} dili aynı zamanda karmaşık veri tipi kullanımını da sağlar. Bunlara bileşik veri tipi de denir çünkü birden çok veri saklarlar, bazı durumlarda birden çok veri tipi de saklayabilirler.

==== Dizi

Dizi, bir araya getirilmiş, birim olarak yönetilen nesneler kümesidir. Dizileri aynı tipte olan elemanlar topluluğu olarak düşünebilirsiniz. Tek boyutlu(liste), iki boyutlu(tablo), üç boyutlu(küp) vb. diziler oluşturmak mümkündür. C{plus}{plus}'daki dizilerin bazı özellikleri şunlardır:

* Dizideki her bir eleman bir değer saklar.

* Dizinin ilk elemanı 0 indeksine sahiptir.

* Dizinin boyutu alabileceği toplam eleman sayısıdır.

* Diziler tek ya da çok boyutlu olabilir.

* Dizinin düzeyi(rank) dizideki boyut sayısıdır.

Bir dizide tek bir veri tipi tutulabilir.

===== Dizileri Oluşturmak ve Kullanmak 

Bir dizi oluştururken bu dizinin saklayacağı veri tipini ve dizinin ismini belirtmeniz gerekir. Tek boyutlu bir dizi tanımlamak için [] kullanılır.

[source,c++]
----
int dizi[10];
----

Dizinin değerlerini diziyi oluşturma anında belirlemek de mümkündür. Derleyici {} parantezleri içerisine koyulan eleman sayısına göre dizinin boyutunu belirler.

[source,c++]
----
int dizi[] = {1, 2, 3, 4 , 5, 6, 7, 8, 9, 10};
----

Dizi boyutu belirlenip atama da yapılabilir.

[source, c++]
----
int dizi[10] = {1, 2, 3};
----

Bu durumda 10 elemanlı bir dizi tanımladık fakat sadece ilk 3 elemanını atadık. Derleyici diğer değerler için varsayılan olan 0 değerini atayacaktır.

==== Dizi Elemanlarına Erişim

Dizi elemanlarına bir kaç farklı yolla erişilebilir, belirli bir elemanın indeksi verilerek ya da döngü ile tüm diziyi dolaşarak elemanlara erişim sağlanabilir.

Aşağıdaki kod örneği 2. indeksteki elemana erişimi göstermektedir:

[source, c++]
----
/// Indeks ile erişim
int sayilar[] = {1, 2, 3, 4, 5};

/// x, 3 değerini içerecektir
int x = sayilar[2];
----

Not: Dizilerin ilk elemanı her zaman 0 indekslidir. N elemanlı bir dizinin son elemanı N-1 indeksli olacaktır. Dizi sınırları dışına çıkılması durumunda sonuç dönmeye devam edecektir fakat bu veri alakasız bir veri olacaktır.

Bunun sebebi dizilerin belirli bir hafıza alanında bir işaretçi olmasıdır. Eğer bu sınırlardan çıkacak olursanız hafızanın başka bir adresini işaret etmiş olursunuz ve hafızanın o adresindeki değer dönüş değeri olarak alınır.

Aşağıdaki örnek dizi içerisinde döngü ile dolaşarak erişimi göstermektedir: 

[source, c++]
----
/// Dizi üzerinde dolaşma
int sayilar[] = {1, 2, 3, 4, 5};

for(int i = 0; i < 5; i++){
    int x = sayilar[i];
}
----

==== Stringler

Stringler karakter dizileridirler. C{plus}{plus} stringleri iki yolla gösterir. Birincisi C dilinden kalma karakter dizisi yöntemidir. Bu yöntemde dikkat edilmesi bir nokta vardır; her stringin son karakteri null karakterine sahip olmalıdır, ASCII karşılığı \0 'dır. Örnek vermek gerekirse:

[source, c++]
----
char dogruString[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
char yanlisString[5] = {'H', 'e', 'l', 'l', 'o'};
cout << dogruString << endl;
cout << yanlisString << endl;
----

Kullanıcılar tarafından en çok yapılan hata '\0' elemanını eleman sayısına katmamak ve '\0' karakterini diziye eklememektir. Null karakterin koyulmaması sonuçta hatalı çıktıya sebep olur çünkü C{plus}{plus} bu diziyi karakter dizisi yani string olarak tanımaz.

Karakter dizisi tanımlamanın bir alternatifi de string literal olarak oluşturmaktır. String literal çift tırnak ("") içerisinde bulunan karakterler dizisidir. Örnek olarak:

[source, c++]
----
char string1[12] = "MerhabaDünya";
char string2[]  = "Dizi boyutu anlasilabilir";
----

İlk örnekte 12 boyutunda bir dizi oluşturulur ve MerhabaDünya string literali bu diziye atanır. İkinci örnekte ise derleyici string literalin boyutundan dizinin boyutunu anlar. String literaller \0 karakterine ihtiyaç duymaz, derleyici bunu kendisi ekleyecektir. Fakat \0 karakteri için bir eleman fazla yazmak kod için sağlıklı olmayacaktır çünkü boş kalan her elemana varsayılan olarak \0 karakteri atanır.

==== Struct (Yapılar)

Diziler bir bileşik veri tipinde birden fazla veriyi bir arada tutabiliyordu, buna karşın bir dizinin tüm elemanları aynı veri tipinde olmak zorundadır. Bu durumda bazı verileri bir arada tutmamız imkansız hale geliyor. Örneğin kahve çekirdeğini ele alalım. Kahve ile ilgili saklayacağımız veriler ismi, menşei ve sertlik derecesi olacaktır. Sertlik derecesini 1 - 10 arasında kabul edersek, iki string ve bir integer değer kahve çekirdeği veri tipini oluşturacaktır.

Bu tip bir yapı kurmak için struct kullanılmalıdır. Aşağıdaki gibi tanımlanabilir: 

[source, c++]
----
struct kahve{
    string isim;
    string mensei;
    int sertlik;
};
----

String veri tipini struct'ımızda kullanmak için C{plus}{plus} dosyasına string header dosyasını eklemeyi unutmayınız (#include <string>). Bu struct'ı oluşturduktan sonra diğer veri tiplerini kullandığımız gibi kullanabiliriz. kahve struct'ını kodumuzda kullanmak için örnekte gösterildiği gibi bu tipte bir değişken oluşturmalıyız.

[source, c++]
----
kahve yeniKahve = {"Strata" , "Columbia" , 10};
kahve kahve2;
kahve2.isim = "Flora";
kahve2.mensei = "Mexico";
kahve2.strength = 9;
----

Örnekte görüldüğü yöntemlerle değer ataması yapılabilir. Nokta operatörü ile struct elemanlarının özelliklerine ulaşılabilir.

==== Union (Birlikler)
Uninonlar birden fazla değer ve veri tipi saklama açısından structlara benzerler. Aradaki fark unionlar aynı anda sadece bir veri saklayabilir. Bu ne anlama geliyor? Aşağıdaki örnekte en iyi şekilde anlatılıyor.

[source, c++]
----
union numerikUnion   
{   
     int intDeger;   
     long longDeger;   
     double doubleDeger;   
};   
numericUnion ornekUnion;   
ornekUnion.intDeger = 3;   
cout << ornekUnion.intDeger << endl;   
ornekUnion.doubleDeger = 4.5;   
cout << ornekUnion.doubleDeger << endl;   
cout << ornekUnion.intDeger << endl;
----

Bu örnekte numerikUnion isimli bir union tanımlıyoruz ve bu tipte ornekUnion isimli bir değişken tanımlıyoruz. Öncelikle intDeger kısmına 3 değerini veriyoruz ve yazdırıyoruz. Daha sonra 4.5 değerini doubleDeger kısmına veriyoruz ve yine yazdırıyoruz. Örnek unionların nasıl çalıştığını son satırda, intValue değerini tekrar yazdırdığımızda gösteriyor. Çıktı 3 yerine 0 gösteriyor. Bunun sebebi doubleDeger elemanına değer atadığımızda intDeğer elemanının sakladığı değerin kaybolması. Unionlar aynı anda sadece bir veri saklayabilir.

Peki struct kullanmak varken union kullanmanın sebebi nedir. Sınırlı hafızaya sahip bir cihazda bir uygulama programladığınızı varsayın. Bu durumlarda union kullanımı struct'a göre daha karlı olabiliyor.

==== Enumerations (Numaralandırılmış Tip)

Değişkenler ve sabitler konusunda oluşturduğunuz programda asla değişmemesi gereken değerlerin sabitler olduğundan bahsetmiştik. Enumeration bir tür sembolik sabit oluşturma yolu olarak kabul edilebilir. Enum kullanımını anlatmanın en yaygın örneği haftanın günleri tanımlamaktır. Haftanın günleri için sadece 7 değer saklanacaktır ancak bu değerler asla değişmeyecektir bu yüzden enum kullanmak mantıklı olacaktır.

Bir enum oluşturmak için gerekli söz dizimi aşağıdaki örnekte gösterildiği gibidir: 

[source, c++]
----
enum Gunler {Pazartesi, Sali, Carsamba, Persembe, Cuma, Cumartesi, Pazar};
----

Varsayılan olarak enum değerleri 0'dan başlayıp birer birer artar. Bunun sonucunda Gunler enumu şu değerleri alacaktır: 

* Pazartesi = 0
* Sali = 1
* Carsamba = 2
* ...

Varsayılan başlangıç değerini belirleyerek değiştirilebilir.

[source, c++]
----
enum Gunler {Pazartesi = 1, Sali, Carsamba, Persembe, Cuma, Cumartesi, Pazar};
----

Bu durumda Pazartesi 1, Sali 2, ... olacaktır.

Enum anahtar kelimesi Gunler tipini oluşturmaktadır. Aşağıdaki kodu inceleyelim:

[source, c++]
----
enum Gunler {Pazartesi = 1, Sali, Carsamba, Persembe, Cuma, Cumartesi, Pazar};
Gunler faturaGunu;
faturaGunu = Persembe;
cout << faturaGunu << endl;
----

İlk satır Gunler enumunu tanımlar ve değerlerini atar. Pazartesi ilk gün olarak belirtildi ve spesifik olarak 1 değeri atandı.

İkinci satırda Gunler enum tipinde bir faturaGunu değişkeni oluşturuldu. Üçüncü satırda faturaGunu değişkenine listedeki değerlerden biri atandı. Son olarak son satırda faturaGunu  değeri yazdırıldı. Eğer bu kodu çalıştırırsanız çıktı olarak Perşembe değil 4 değerini aldığınızı göreceksiniz. Dahilen, enumlardaki sabitler sayıdır ve metin olarak atanamazlar.



== Kontrol

=== C{plus}{plus} Operatörleri

Operatör derleyiciye matematik ve lojik işlem yaptıran sembollerdir. C{plus}{plus}'da 6 tür operatör vardır: 


*   Aritmetik Operatörler

*   İlişkisel Operatörler

*   Lojik Operatörler

*   Bit Düzeyinde Operatörler

*   Atama Operatörleri

*   Diğer Operatörler

==== Aritmetik Operatörler
C{plus}{plus} dili aşağıdaki aritmetik operatörlere sahiptir: 

|====
| Operatör | Tanım
| + | İki elemanı toplar 
| - | İkinci elemanı birinciden çıkartır
| * | İki elemanı birbiriyle çarpar
| / | Bölme işlemi yapar
| % | Birinci elemanın ikinci elemana göre modunu alır
| {plus}{plus} | Elemanın değerini bir arttırır 
| - - | Elemanın değerini bir azaltır
|====

==== İlişkisel Operatörler

|====
| Operatör  | Tanım
| == | İki değerin eşitliğini kontrol eder eşitse true, değilse false döndürür
| != | İki değerin eşit olmamasını kontrol eder eşit değilse true, eşitse false döndürür
| > | Soldaki elemanın daha büyük olma durumunu kontrol eder, büyükse true, değilse false döndürür.
| < | Sağdaki elemanın daha büyük olma durumunu kontrol eder, büyükse true, değilse false döndürür.
| >= | Soldaki elemanın daha büyük olma veya eşit olma durumunu kontrol eder, büyükse true, değilse false döndürür.
| \<= | Sağdaki elemanın daha büyük olma veya eşit olma durumunu kontrol eder, büyükse true, değilse false döndürür.
|====

==== Lojik Operatörler

|====
| Operatör | Tanım 
| && | AND operatörü, eğer here iki eleman da doğruysa true döner. 
| \|\| |  OR operatörü, eğer iki elemandan biri doğruysa true döner. 
| ! | NOT Operatörü, mevcut lojik durumun tersini alır.
|====

==== Bit Düzeyinde Operatörler

|====
| p | q | p & q | p OR q | p ^ q
| 0 | 0 | 0 | 0 | 0
| 0 | 1 | 0 | 1 | 1
| 1 | 1 | 1 | 1 | 0
| 1 | 0 | 0 | 1 | 1
|====

|====
| Operatör | Tanım 
| & | AND işlemi yapar
| \|\| | OR işlemi yapar
| ^ | XOR işlemi yapar
| ~ | Değişkenin tersini alır
| << | Sola bit kaydırır
| >> | Sağa bit kaydırır
|====

==== Atama Operatörleri

|====
| Operatör | Tanım
| = | Atama işlemi yapar.
| += | Soldaki elemana sağdaki elemanla toplamını atar
| -= | Soldaki elemana sağdaki elemanla farkını atar
| *= | Soldaki elemana sağdaki elemanla çarpımını atar
| %= | Soldaki elemana sağdaki elemana göre modunu atar
| &= | Bit düzeyinde AND işlemi yapıp atar
| ^= | Bit düzeyinde OR işlemi yapıp atar
|====

==== Diğer Operatörler

|====
| Operatör | Tanım
| sizeof | Değişkenin kapladığı alanı döndürür. Örneğin, sizeof(a), a int bir değer ise 4 döndürür
| Durum ? X : Y | Eğer durum doğru ise X değeri yanlış ise Y değeri döner
| . (nokta) ve \-> (ok işareti) | Sınıf, struct ve unionlardaki elemanları göstermek için kullanılır
| & | Değişkenin adresini döndürür. Örneğin &a; a değişkeninin gerçek adresini verir.
| * | Değişkenin işaretçisidir. Örneğin *a; a değişkeninin işaretçisidir.
|====

=== Karar Bildirimleri

Karar bildirim yapıları programcının bir ya da daha fazla durumu tanımlamasına ve program tarafından test edilmesine ihtiyaç duyar, bununla beraber eğer durum doğru ise içerisindeki kod parçası çalışır, yanlış ise kaldığı yerden devam eder.

C{plus}{plus} dili aşağıdaki karar bildirim ifadelerine sahiptir:

|====
| İfade | Tanım
| if | If durumu bir ya da daha fazla işlemin sonucu olan bir boolean değer ile çalışır.
| if - else | Boolean değerin false olması halinde çalışması istenen bir parça varsa if durumunun ardından else durumu eklenir.
| switch | Switch durumu değişkeni belirli değerler listesinde aramayı sağlar.
| iç içe if | Bir if durumu içerisine başka bir if durumu yerleştirilebilir.
| iç içe switch | Bir switch durumu içerisine başka bir switch durumu yerleştirilebilir.
|====

==== if İfadeleri

C{plus}{plus}'da if ifadeleri bool mantığıyla alakalıdır. Eğer if ifadesi doğruysa ilgili kod bloğu çalıştırılır. Eğer if ifadesi yanlışsa if bloğunun kapanışından çalıştırılmaya devam edilir.

Aşağıdaki örnek bir if ifadesini göstermektedir:

[source, c++]
----
int x = 5;
int y = 10;
if(y > x){
    cout << "y buyuktur x";
}
----

Tek satırlık if ifadelerinde süslü parantezler kullanılmayabilir. Derleyici süslü parantez görmediğinde tek satırlık bir if ifadesi olduğunu anlar ve eğer durum doğru ise o satırı çalıştırır. Çok satırlı if durumlarında ise kod bloğu süslü parantez içerisine alınmalıdır.

C{plus}{plus}'da if durumları else kalıbıyla ilişkilendirilebilir. else kalıbı if ifadesi yanlış olduğu zaman çalışır.

==== if else İfadeleri

[source,c++]
----
int x = 5;
int y = 10;
if(y > x){
    cout << "y buyuktur x";
}
else{
    cout << "x >= y";
}
----

if ifadeleri ayrıca else if kalıbıyla da ilişkilendirilebilir. Eğer sıralı olarak bulunan bu kalıplardan bir tanesi true döndürürse bu ifadeyle ilişkili kodlar yapılmış olur.

==== else if İfadeleri

[source,c++]
----
int x = 5;
int y = 10;
if(y > x){
    cout << "y buyuktur x";
}
else if (x > y){
    cout << "x buyuktur y";
}
else {
    cout << "x esittir y";
}
----

Birden fazla else if ifadesi yazmak mümkündür. Örneğin 5 tane else if ifadesi kullanmak yerine sonraki konuda anlatılan switch ifadesini kullanabilirsiniz.

==== switch İfadeleri

Eğer kod içerisinde çok fazla else if ifadesi varsa kodunuz anlaşılmaz ve karmaşık olabilir. Bu durumda daha iyi bir çözüm yöntemi olan switch ifadesi kullanılmalıdır. switch ifadesi çoklu else if ifadelerinin karşılığıdır. Aşağıdaki örnek switch ifadelerinin nasıl kullanıldığını göstermektedir.

[source, c++]
----
char karakter = 'y';  
switch (karakter)  
{  
   case 'y':  
      // Karakter değerinin y olduğu durumda çalışacak kod bloğu.  
      break;  
   case 'Y':  
      // Karakter değerinin Y olduğu durumda çalışacak kod bloğu.   
      break;  
   case 'n':  
      // Karakter değerinin n olduğu durumda çalışacak kod bloğu.    
      break;  
   default:  
      // Karakter değerinin üstteki değerlerden herhangi biri olmaması durumunda çalışacak kod
      break;  
}
----

Örnekte kullanılan default: başlığı yazılan değerlerden herhangi birinin çalışmaması dahilinde çalıştırılan kod parçasını saklar kullanılması opsiyoneldir. 

Her case ifadesinde break anahtar kelimesi kullanılmıştır. Bu diğer case ifadeleri atlamayı kontrol etmek, engellem için kullanılmalıdır. 

Break ifadesinin kullanılmaması durumunda ifadeyi sağlayan case ifadesi ve ondan sonraki tüm case ifadeleri de çalıştırılacaktır.

==== Koşullu (Üçlü) İfadeler

C{plus}{plus} koşullu operatörü aynı zamanda üçlü operatörü ismine sahiptir çünkü üç operand alır. Çalışma mantığı if else yapısıyla benzerdir. İlk operand bool bir değer döndürür. Eğer değer doğru ise ikinci operande çalıştırılır, eğer yanlış ise üçüncü operand çalıştırılır. Şu şekilde gösterilir.

[source, c++]
----
int i = 1, j = 2;   
cout << ( i > j ? i : j ) << " daha buyuktur." << endl; 
----

==== Döngü Kontrol Durumları

Döngü kontrol durumları normal işleyişi değiştirmek için kullanılır. Eğer bir tanım aralığından çıkılırsa o tanım aralığında tanımlanmış tüm nesneler yok edilir. C{plus}{plus} dilinde aşağıdaki döngü kontrol durumları vardır:

|====
| Durum | Tanım
| break | Döngü veya switch durumunu o anda bitirir ve kaldığı döngüden veya bloktan devam eder.
| continue | Döngünün başına, kontrol kısmına gider.
| goto | Seçilen isimlendirilmiş duruma gider, kullanılması tavsiye edilmez.
|====

=== Tekrarlama Bildirimleri

Tekrarlama bildirimleri bir kod bloğunu birden fazla kez çalıştırmak için kullanılır. Tekrarlama bildirimleri içerisinde bulunan durum veya durumların dışına çıkılana kadar çalışmaya devam eder. C{plus}{plus} dilinde aşağıdaki tekrarlama bildirimleri vardır: 

|====
| Tekrar Türü | Tanım
| while | Verilen şart doğru iken çalışmaya devam eder. While bloğunun başına gelindiğinde tekrar kontrol edilir.
| for | Döngü değişkenine sahiptir ve her seferinde bu değişkenin değerini değiştirip verilen şarta uyup uymadığını kontrol eder.
| do while | While ile aynıdır, yalnızca kontrol bloğun sonunda yapılır.
| iç içe döngü | Bir döngü içerisinde başka bir döngü oluşturmak mümkündür.
|====

==== for Döngüsü
for döngüsü belirtilen ifade yanlış olana kadar belirli bir kod bloğunu çalıştırır. Şu şekilde tanımlanabilir.

[source, c++]
----
for (int i = 0 ; i < 10; i++)   
{  
     
}
----

Öncelikle tekrarlamayı sağlamak için bir değişken oluşturulur ve değer verilir (genellikle 0 ile başlar). Daha sonra hangi koşulu sağlaması gerektiği ve döngü her çalıştığında değer üzerinde nasıl bir değişiklik yapılacağı belirtilir.

==== while Döngüsü
while döngüsü verilen durum doğru olduğu sürece kod bloğunu çalıştırmayı sağlar. Şu şekilde tanımlanabilir.

[source, c++]
----
int i = 0;
while (i<10){
    i++;
}
----

doWhile döngüsü ise while'dan farklı olarak durum kontrolünü kod bloğunun en sonunda yapar. Şu şekilde gösterilir.

[source, c++]
----
int i = 0;
do {
    i++;
}while (i<10)
----

==== İç İçe Döngüler

C{plus}{plus}'da iç içe döngüler oluşturmak mümkündür. En yaygını iç içe for döngüleridir. İç içe döngüler için bir örnek oyunlar için verilebilir, mesela oyunculara 52'lik bir desteden 4 kart vermek. Bu durumda dış döngü 0'dan 51'e kadar toplam kart sayısını sayacak, iç döngü ise 0'dan 3'e kadar 4 kartın verilmesini sayacaktır.

[source, c++]
----
for (int i=0; i<52; i++){
    for(int j=0; j<4; j++){
        
    }
}
----

== Fonksiyonlar ve Nesneler

=== Fonksiyonlar
Fonksiyonlar programa birimsellik sağlamak için kullanılan bileşenlerdir. Fonksiyon kullanan uygulamaların anlaşılması, düzeltilmesi daha kolaydır.

Fonksiyon ismi olan bir kod dizisidir ve programın bazı yerlerinde çağrılabilir. En yaygın kullanımı şu şekildedir:

[source,c++]
----
veriTipi isim (parametre1, parametre2, ...) {
    //fonksiyon
}
----

* Veri tipi fonksiyonun döndüreceği veri tipidir.
* İsim fonksiyonu çağırırken belirtmek için kullanılır.
* Parametreler: Her parametre veri tipiyle beraber yazılır ve virgül ile ayrılır. Parametrelerin amacı fonksiyonun çağırıldığı yerde içerisinde kullanılacak değerleri almaktır.

==== Prototip Tanımı

[source,c++]
----
int toplama(int,int);
----

==== Fonksiyon Çağırımı

Bir fonksiyonu program içerisinde çağırmak için fonksiyonun ismiyle beraber istenilen parametreleri parantez içerisinde göndermek yeterlidir. Örnek olarak: 

[source,c++]
----
using namespace std;

int toplama(int,int);

int main(){
    cout << "3 + 5 = " << toplama(3,5) <<endl;///Fonksiyon çağırılması
    return 0;
}

int toplama(int sayi1, int sayi2){///Fonksiyon tanımlanması
    return sayi1+sayi2;
}
----

Bu örnekte sonucu yazdırmak için döndürülen değerden yararlanılır.

Çıktı:

----
3 + 5 = 8
----

[source,c++]
----
using namespace std;

int max(int sayi1, int sayi2){///Fonksiyon tanımlanması
    int sonuc;
    if(sayi1 > sayi2)
        sonuc = sayi1;
    else if(sayi2 > sayi1)
        sonuc = sayi2;
    else{
        cout << "Iki sayi birbirine esittir." << endl;
        return 0;
    }
    cout << sonuc << " buyuktur." << endl;
    return 0;
}

int main(){
    max(3,5);///Fonksiyon çağırılması
    return 0;
}
----

Bu örnekte ise sonuç fonksiyonun içerisinde cout fonksiyonuyla yazdırılır, bu yüzden fonksiyonu çağırırken cout içinde kullanmaya gerek olmadı. Ancak önceki örnekteki fonksiyonu cout kullanmadan çağırmayı denersek sonuç şöyle olur: 

[source,c++]
----
using namespace std;

int toplama(int sayi1, int sayi2){///Fonksiyon tanımlanması
    return sayi1+sayi2;
}

int main(){
    toplama(3,5);///Fonksiyon çağırılması
    return 0;
}
----

Çıktı:

----

----

Görüldüğü gibi return ile döndürülen değer ayrı bir fonksiyon kullanılmadıkça yazdırılamaz.

Fonksiyonlar iki farklı şekilde çağırılabilir:

1. Değer ile
2. Referans ile

==== Değer ile Fonksiyon Çağırımı

Değer ile çağırma yöntemi fonksiyon parametrelerine argümanların asıl değerlerini göndererek kullanılır. Daha önce kullandığımız fonksiyonlar değer ile çağırma yöntemine örnek gösterilebilir.

==== Referans ile Fonksiyon Çağırımı

Referans ile çağırma yöntemi fonksiyon parametrelerine argümanın referansının gönderilmesyle kullanılır. İşaretçi kullanarak ya da kullanmayarak 2 şekilde yapılabilir.

===== İşaretçi Olmadan Referans

[source,c++]
----
using namespace std;

int swap(int& sayi1, int& sayi2){
    int temp = sayi1;///temp = temporary (geçici)
    sayi1 = sayi2;
    sayi2 = temp;
}

int main () {
    int x = 40;
    int y = 100;

    cout << "Degistirmeden once x: " << x << " y: " << y << endl;

    swap(x,y);

    cout << "Degistirdikten sonra once x: " << x << " y: " << y << endl;

    return 0;
}
----

Derleyici bu fonksiyonun referans ile çağırıldığını fonksiyon tanımındaki & işaretinden anlıyor. swap() fonksiyonunda sayi1 ve sayi2 değişkenlerinin adresleri alınıyor ve bu adreslerin yerleri değiştiriliyor. Böylece sayi1 değeri ile sayi2 değeri yer değiştirmiş oluyor. Örneğin çıktısı aşağıdaki gibi olacaktır: 

----
Degistirmeden once x: 40 y: 100
Degistirdikten sonra once x: 100 y: 40
----

===== İşaretçi ile Referans

[source,c++]
----
using namespace std;

int swap(int* sayi1, int* sayi2){
    int temp = *sayi1;///temp = temporary (geçici)
    *sayi1 = *sayi2;
    *sayi2 = temp;
}

int main () {
    int x = 40;
    int y = 100;

    cout << "Degistirmeden once x: " << x << " y: " << y << endl;

    swap(&x ,&y);

    cout << "Degistirdikten sonra once x: " << x << " y: " << y << endl;

    return 0;
}
----

Bu durumda fonksiyona değişkenin kendisinden ziyade adresi gönderilir. Bu bağlamda gönderilen adreste saklanan değere ulaşabilmek için * operatörü kullanılmak zorundadır. *sayi1 ve *sayi2, sayi1 ve sayi2'nin adreslerinde saklanan değerleri verir. Fonksiyon çıktısı yine aynı şekilde olacaktır.

==== Varsayılan Parametre Değerleri
Fonksiyon tanımlarken parametrelere varsayılan değer atanabilir. Bu değer fonksiyon çağırılırken parametrenin boş bırakılması durumunda kullanılır. Şu şekilde yazılır: 

----
Degistirmeden once x: 40 y: 100
Degistirdikten sonra once x: 100 y: 40
----

[source,c++]
----
using namespace std;

int toplama(int sayi1, int sayi2 = 5){///Varsayılan parametre tanımlanması
    return sayi1+sayi2;
}

int main () {

    int x = 20;
    int y = 30;

    cout << "x + y = " << toplama(x,y) << endl;
    cout << "toplama(x) = " << toplama(x) << endl;///Varsayılan parametre kullanımı

    return 0;
}
----

Çıktı: 

----
x + y = 50
toplama(x) = 25
----

Örnekte görüldüğü gibi sayi2 parametresinin yazılmadığı fonksiyon çağırımında varsayılan parametre değeri olan 5 kullanıldı ve çıktı olarak 25 yazdırıldı.

==== Özyinelemeli Fonksiyonlar (Recursion)
Kendini çağıran fonksiyonlara özyinelemeli fonksiyonlar denir.

[source,c++]
----
using namespace std;

int faktoriyel(int n){
    if(n>1)
        return n*faktoriyel(n-1);///Özyineleme
    else
        return 1;
}

int main () {
    cout << "3 faktoriyel = " << faktoriyel(3) << endl;
    return 0;
}
----

Çıktı: 

----
3 faktoriyel = 6
----

1. İlk faktoriyel() fonksiyonundaki if durumu doğru döner.
return n*faktoriyel(n-1); ifadesi çalıştırılır ve parametresi 2 olan faktoriyel() fonksiyonu çağırılır.

2. İkinci faktoriyel() fonksiyonundaki if durumu da doğru dönecektir. return num*factorial(num-1); ifadesi çalıştırılır ve parametresi 1 olan faktoriyel() fonksiyonu çağırılır.

3. Üçüncü faktoriyel() fonksiyonunda if durumu false dönecektir. İkinci faktoriyel() fonksiyonuna 1 değeri döndürülür.

4. İkinci faktoriyel() fonksiyonu birinci faktoriyel() fonksiyonuna 2 değerini döndürür.

5. Son olarak ilk faktoriyel() fonksiyonu main() fonksiyonuna 6 değerini döndürür ve ekranda yazılır.

==== Inline Fonksiyonlar

Inline fonksiyon genellikle sınıflarla kullanılan güçlü bir konsepttir. Eğer bir fonksiyon inline ise fonksiyon kod içerisinde her çağırılışında fonksiyonu oraya kopyalar. Programın hızı açısından önemlidir fakat inline fonksiyonlar oldukça kısa olmalıdır.

[source,c++]
----
using namespace std;

inline int Max(int x, int y) {
   return (x > y)? x : y;
}

int main( ) {

   cout << "Max(20,10): " << Max(20,10) << endl;
   cout << "Max(0,200): " << Max(0,200) << endl;
   cout << "Max(100,1010): " << Max(100,1010) << endl;

   return 0;
}
----

=== Nesneler ve Sınıflar

C{plus}{plus} dilinin asıl amacı C diline nesneye yönelik olma özelliğini katmaktır ve sınıflar da bunun ana özelliğidir denilebilir.

Sınıflar kendinize özel, üzerinde değişiklik yapılabilen veri tipleridir. Sınıf dosyası genellikle nesneler için taslak olarak kabul görür. 

Sınıflar struct'ların genişletilmiş halidir. Struct'lar gibi veri elemanları içerebilirler fakat farklı olarak fonksiyon da içerebilirler. 

==== C{plus}{plus}'da Sınıf Tanımlaması

Bir sınıf tanımlandığında yeni bir veri tipi için taslak hazırlanmış demektir. Herhangi bir veri tanımlamaz fakat bu sınıfın isminin ne anlama geldiğini tanımlar. Söz dizimi örnekteki gibidir: 

[source,c++]
----
class Zaman{
public:
    int saat;
    int dakika;
    int saniye;
};
----

public deyimi özelliklerin sınıfın elemanları tarafından erişilebilir olduğunu belirtmek için kullanılır. Bunun yanısıra private ve protected deyimleri de kullanılabilir ancak bu konuya daha sonra geleceğiz.

==== C{plus}{plus}'da Nesne Tanımlanması

Sınıf, nesneler için taslak niteliğindedir, yani bir nesne bir sınıftan oluşturulabilir. Nesne tanımlaması temel veri tipli değişkenler tanımlamasıyla aynıdır. Şu şekilde gösterilebilir:

----
Zaman zaman1;
Zaman zaman2;
----

Her iki nesne de sınıf içerisindeki değişkenlere sahip olur.

==== Veri Elemanlarına Erişim

Public veri elemanlarına doğrudan erişim operatörü(.) ile erişilebilir. 

[source,c++]
----
using namespace std;

class Zaman{
public:
    int saat;
    int dakika;
    int saniye;
};

int main () {
    Zaman zaman1;

    zaman1.saat=7;
    zaman1.dakika=13;
    zaman1.saniye=51;

    Zaman zaman2;

    zaman2.saat=3;
    zaman2.dakika=46;
    zaman2.saniye=11;

    int saniyeBazindaZaman;

    saniyeBazindaZaman = zaman1.saat*3600 + zaman1.dakika*60 + zaman1.saniye;
    cout << "zaman1 nesnesinin saniye bazindaki degeri: " << saniyeBazindaZaman << endl;

    saniyeBazindaZaman = zaman2.saat*3600 + zaman2.dakika*60 + zaman2.saniye;
    cout << "zaman2 nesnesinin saniye bazindaki degeri: " << saniyeBazindaZaman << endl;

    return 0;
}

----

Çıktı: 

----
zaman1 nesnesinin saniye bazindaki degeri: 26031
zaman2 nesnesinin saniye bazindaki degeri: 13571
----

Örnekte görüldüğü gibi zamanın saniye bazındaki halini görmek için zaman1 ve zaman2 nesnelerinin içerisinde bulunan saat, dakika ve saniye elemanları ile işlem yaptık ve bu elemanlara erişmek için "." operatörünü kullandık.

Not: Private ve protected elemanlara "." operatörü ile doğrudan erişim mümkün değildir. Bu elemanlara nasıl erişileceğini ileride göreceğiz.

==== Üye Fonksiyonlar

Üye fonksiyonlar, diğer değişkenler gibi bir sınıf içerisinde tanımlanan ya da sadece prototipi olan sınıf elemanlarıdır. Bulunduğu sınıfa ait olan her nesne için işlem yapabilir ve o nesne için tüm elemanlara erişim hakkı vardır. Üye fonksiyonların hepsi inline fonksiyonlardır ve bu programın hızını arttırmayı sağlar.

Sınıf elemanına doğrudan erişim yerine üye fonksiyonla erişmeyi deneyelim: 

[source,c++]
----
using namespace std;

class Zaman{
public:
    int saat;
    int dakika;
    int saniye;
    int saniyeBazindaZaman(){
        return saat*3600 + dakika*60 + saniye;
    }
};

int main () {
    Zaman zaman1;

    zaman1.saat=7;
    zaman1.dakika=13;
    zaman1.saniye=51;

    Zaman zaman2;

    zaman2.saat=3;
    zaman2.dakika=46;
    zaman2.saniye=11;

    cout << "zaman1 nesnesinin saniye bazindaki degeri: " << zaman1.saniyeBazindaZaman() << endl;

    cout << "zaman2 nesnesinin saniye bazindaki degeri: " << zaman2.saniyeBazindaZaman() << endl;

    return 0;
}
----

Örnekte görüldüğü gibi diğer değişkenler gibi bir fonksiyonu da sınıf içerisinde tanımlayıp "." operatörüyle bu sınıfın nesnelerinden erişebiliyoruz. 

Not: Fonksiyonların sınıf dışında tanımlanması da mümkündür. Bunun için kapsam alanı çözünürlüğü operatörü "::" kullanılmalıdır ve prototipi sınıfın içerisinde tanımlanmış olmalıdır. Şu şekilde gösterilebilir: 

[source,c++]
----
class Zaman{
public:
    int saat;
    int dakika;
    int saniye;
    int saniyeBazindaZaman();
};

int Zaman::saniyeBazindaZaman(){
    return saat*3600 + dakika*60 + saniye;
}

----

Yukarıda bahsedilen özellikleri kullanarak nesnenin özelliklerini değiştirip okutabilecek (set - get) fonksiyonları yazılabilir: 

[source,java]
----
using namespace std;

class Zaman{
public:
    int saat;
    int dakika;
    int saniye;
    int saniyeBazindaZaman();
    void setSaat(int s);
    void setDakika(int d);
    void setSaniye(int sn);
};

int Zaman::saniyeBazindaZaman(){
    return saat*3600 + dakika*60 + saniye;
}

void Zaman::setSaat(int s){
    saat = s;
}

void Zaman::setDakika(int d){
    dakika = d;
}

void Zaman::setSaniye(int sn){
    saniye = sn;
}

int main () {
    Zaman zaman1;

    zaman1.setSaat(7);
    zaman1.setDakika(13);
    zaman1.setSaniye(51);

    Zaman zaman2;

    zaman2.setSaat(3);
    zaman2.setDakika(46);
    zaman2.setSaniye(11);

    cout << "zaman1 nesnesinin saniye bazindaki degeri: " << zaman1.saniyeBazindaZaman() << endl;

    cout << "zaman2 nesnesinin saniye bazindaki degeri: " << zaman2.saniyeBazindaZaman() << endl;

    return 0;
}
----

Çıktı:

----
zaman1 nesnesinin saniye bazindaki degeri: 26031
zaman2 nesnesinin saniye bazindaki degeri: 13571
----

=== Kapsülleme

Genellikle nesneye yönelik programlamanın en önemli özelliği olarak kabul edilen kapsülleme bir sınıfa ait elemanların erişilebilirliğini tanımlamak için kullanılabilir. C{plus}{plus} sınıflarda kapsülleme yapmaya yardım etmek için erişim niteleyiciler kullanımını sağlar. 

Kapsülleme üye değişkenleri doğrudan değiştirmeyi engellemek için kullanılır. 

[source, c++]
----
using namespace std;

class Dikdortgen{
private:
    int _uzunluk;
    int _genislik;
public:
    void setUzunluk(int u);
    void setGenislik(int g);
    int getUzunluk();
    int getGenislik();
    int getAlan();
};

/// Üye Fonksiyonların Tanımlamaları
void Dikdortgen::setUzunluk(int u) {
    uzunluk = u;
}

void Dikdortgen::setGenislik(int g) {
    genislik = g;
}

int Dikdortgen::getUzunluk() {
    return uzunluk;
}

int Dikdortgen::getGenislik(){
    return genislik;
}

int Dikdortgen::getAlan(){
    return uzunluk*genislik;
}

int main() {

    Dikdortgen kutu;

    kutu.setGenislik(5);
    //kutu.uzunluk=10; ///Hata: Private olan bir elemana doğrudan erişilemez.( Kapsülleme )
    kutu.setUzunluk(10);/// Üye fonksiyon kullanılmalıdır

    cout << "kutu uzunlugu: " << kutu.getUzunluk() << endl;
    //cout << "kutu genisligi: " << kutu.genislik << endl; ///Hata: Private elemana doğrudan erişilemez ( Kapsülleme )
    cout << "kutu genisligi: " << kutu.getGenislik() << endl;/// Üye fonksiyon kullanılmalıdır

    cout << "kutu alani: " << kutu.getAlan() << endl ;

    return 0;
}
----


==== Sınıf Erişim Niteleyiciler

Veri gizleme nesneye yönelik programlamanın önemli özelliklerinden biridir. Program fonksiyonlarının sınıf elemanlarına doğrudan erişmeyi engeller. 3 adet erişim niteleyici vardır, bunlar private, public ve protected olarak adlandırılır.

Bir sınıfta birden fazla erişim niteleyici bulunabilir. Erişim niteleyici kullanılmadığı durumda varsayılan olarak private olurlar.

[source,c++]
----
class Niteleyici {

   public:

   // public elemanlar

   protected:

   // protected elemanlar

   private:

   // private elemanlar

};
----

===== Public Üyeler
Public üyeler sınıfın dışında da kullanılabilir. Public değişkenlerin değerleri üye fonksiyon kullanmadan da değiştirilebilir veya yazdırılabilir.

[source,c++]
----
using namespace std;

class Dikdortgen{
public:
    int uzunluk;
    int genislik;
    void setUzunluk(int u);
    void setGenislik(int g);
};

void Dikdortgen::setUzunluk(int u) {
    uzunluk = u;
}

void Dikdortgen::setGenislik(int g) {
    genislik = g;
}

int main() {

    Dikdortgen kutu;

    kutu.setGenislik(5);
    kutu.uzunluk=10;    ///Hata vermez. Bu atama şekli sadece public elemanlara yapılabilir

    return 0;
}
----

===== Private Üyeler
Private bir üye fonksiyon veya değişkene sınıfın dışından erişilmesi mümkün değildir. Yalnızca sınıftan veya friend fonksiyonlarla private üyelere erişilebilir. Varsayılan olarak bir sınıfın tüm elemanları private üye olacaktır, örneğin aşağıdaki örnekte uzunluk değişkeni herhangi bir niteleyici altında kalmadığı için private üye olacaktır.

[source,java]
----
class Dikdortgen{
    int uzunluk; /// private üye
public:
    int genislik;
    void setUzunluk(int u);
    void setGenislik(int g);
};
----

Yukarıdaki özellikleri kapsayan bir örnek hazırlamak istersek şöyle bir program yazabiliriz: 

[source,c++]
----
using namespace std;

class Dikdortgen{
public:
    void setUzunluk(int u);
    void setGenislik(int g);
    int getUzunluk();
    int getGenislik();
    int getAlan();
private:
    int uzunluk;
    int genislik;
};

/// Üye Fonksiyonların Tanımlamaları
void Dikdortgen::setUzunluk(int u) {
    uzunluk = u;
}

void Dikdortgen::setGenislik(int g) {
    genislik = g;
}

int Dikdortgen::getUzunluk() {
    return uzunluk;
}

int Dikdortgen::getGenislik(){
    return genislik;
}

int Dikdortgen::getAlan(){
    return uzunluk*genislik;
}

int main() {

    Dikdortgen kutu;

    kutu.setGenislik(5);
    //kutu.uzunluk=10; ///Hata: Private olan bir elemana doğrudan erişilemez.
    kutu.setUzunluk(10);/// Üye fonksiyon kullanılmalıdır

    cout << "kutu uzunlugu: " << kutu.getUzunluk() << endl;
    //cout << "kutu genisligi: " << kutu.genislik << endl; ///Hata: Private elemana doğrudan erişilemez
    cout << "kutu genisligi: " << kutu.getGenislik() << endl;/// Üye fonksiyon kullanılmalıdır

    cout << "kutu alani: " << kutu.getAlan() << endl ;

    return 0;
}
----

Çıktı:

----
kutu uzunlugu: 10
kutu genisligi: 5
kutu alani: 50
----

===== Protected Üyeler
Protected üyeler private üyelere oldukça benzerdir, tek fark protected üyelere çocuk sınıflardan yani türetilmiş sınıflardan erişilebilir.

Türetilmiş sınıflar ve kalıtım konusundan daha sonra bahsedilecek. Şimdilik aşağıda Dikdortgen sınıfından türetilmiş turetilmisDikdortgen sınıfını inceleyebilirsiniz.

[source,c++]
----
using namespace std;

class Dikdortgen{
protected:
    int uzunluk;
    int genislik;
};

class turetilmisDikdortgen:Dikdortgen{///Türetilmiş(çocuk) sınıf
public:
    void setUzunluk(int u);
    int getUzunluk();
};

/// Çocuk Sınıfın Üye Fonksiyon Tanımlamaları
void turetilmisDikdortgen::setUzunluk(int u) {
    uzunluk = u;
}

int turetilmisDikdortgen::getUzunluk() {
    return uzunluk;
}

int main () {
    turetilmisDikdortgen kutu;

    ///kutu.uzunluk = 85;///Hata: Protected üyeye ana veya türetilmiş sınıf dışında erişilemez
    kutu.setUzunluk(85);/// Üye fonksiyon kullanılmalıdır

    cout << "kutu uzunlugu: " << kutu.getUzunluk() << endl ;

    return 0;
}
----

Çıktı:

----
kutu uzunlugu: 85
----

=== Const Nesneler

const anahtar kelimesinin sabit belirlemek için kullanıldığını ve çalışma süresi boyunca değerinin değiştirilemeyeceğini unutmayın. const anahtar kelimesi nesneler için de kullanılabilir; nesnenin değişmez olduğunu belirtir. Oluşturulan nesneye çok kısıtlı bir şekilde erişilebilmesine yardımcı olur yani kapsüllemeyi destekleyen bir özelliktir denilebilir.

[source,c++]
----
#include 
using namespace std;

class Dikdortgen{
private:
    int _uzunluk;
    int _genislik;
public:
    Dikdortgen();
    Dikdortgen(int u, int g);
   // void setUzunluk(int u) ;///Set fonksiyonları const olamaz çünkü const bir fonksiyon üye elemanlar üzerinde değişiklik yapamaz.
   // void setGenislik(int g);///const olamayacakları için const bir nesne tarafından erişilemezler
    int getUzunluk() const;///Get fonksiyonları const olabilir çünkü elemanlar üzerinde bir değişiklik yapmaz sadece değerini döndürür.
    int getGenislik() const;
    int Alan() const;
};

/// Yapıcı Fonksiyonların Tanımlamaları
Dikdortgen::Dikdortgen() : _uzunluk(5), _genislik(5) {}
Dikdortgen::Dikdortgen(int u, int g) : _uzunluk(u), _genislik(g) {}

/// Üye Fonksiyonların Tanımlamaları
int Dikdortgen::getUzunluk() const{
    return _uzunluk;
}

int Dikdortgen::getGenislik() const{
    return _genislik;
}

int Dikdortgen::Alan() const{
    return _uzunluk*_genislik;
}

int main() {

    const Dikdortgen varsayilanKutu;/// Const nesne tanımlaması

    cout << "varsayilanKutu uzunlugu: " << varsayilanKutu.getUzunluk() << endl;
    cout << "varsayilanKutu genisligi: " << varsayilanKutu.getGenislik() << endl;/// Üye fonksiyon kullanılmalıdır
    cout << "varsayilanKutu alani: " << varsayilanKutu.Alan() << endl ;

    const Dikdortgen kutu2(10,20);

    cout << "kutu2 uzunlugu: " << kutu2.getUzunluk() << endl;
    cout << "kutu2 genisligi: " << kutu2.getGenislik() << endl;
    cout << "kutu2 alani" << kutu2.Alan() << endl;
    return 0;
}
----

==== İşaretçiler (Pointers)

İşaretçileri anlamak için öncelikle bilgisayarların uygulamadaki verileri nasıl tuttuğunu anlamak gerekir. Programınızda bir değişken oluşturduğunuzda derleyicinize bu değişkenin bir parçası olan veriyi tutmasını sağlamış olursunuz. Değişken oluşturulduğunda hafızanın neresinde saklandığının bir önemi yoktur. Değişkene referans göstermek değişkenin saklandığı adrese erişim sağlar.

[source, c++]
----
int sayi = 5;
cout << "sayi degiskeninin saklandigi adres: " << &sayi << endl;
----

Örnekte görüldüğü gibi çıktı olarak farklı bir değer oluştu, bu değer oluşturulan değişkenin adresidir.

İşaretçi aslında bir nesnenin hafızadaki adresini tutan bir değişkendir. İşaretçileri kullanmak için işaretçi değişkeni tanımlanmalıdır. Örnek olarak; eğer oluşturduğumuz sayi değişkeninin adresine işaret etmek üzere bir işaretçi oluşturabiliriz.

[source, c++]
----
int sayi = 5;
int* pSayi = &sayi;
----

Not: İşaretçileri kullanırken dikkat edilmesi gereken bir husus. Bir pointer tanımlarken mutlaka nullptr, 0 veya bir adres değerine eşitlenmelidir. İşaretçi bir değişkene değer atamamak farklı debug yapmayı zorlaştıracak ve güvenlik sorunları yaratacak bir hatadır.

[source, c++]
----
int* pSayi; ///Önerilmez
----

Son olarak, bir işaretçi oluştururken oluşturduğunuz türün işaret edeceğiniz türle aynı olduğundan emin olun. Bu önemli bir konudur çünkü farklı veri tiplerinin depoladığı bit sayısı farklıdır.


==== Dereference Operator
(*) operatörü işaretçi sembolü olduğu gibi aynı zamanda dereference sembolüdür. Peki dereference nedir? Aşağıdaki kod örneğine bakalım.

[source, c++]
----
int sayi = 7;   ///7 değerini tutan basit bir değişken
int* pSayi = &sayi;///sayi değişkeninin adresini tutan işaretçi
cout << pSayi << endl; ///sayi değişkeninin adresini yazdırır
cout << *pSayi << endl; //// sayi değişkeninin adresinin gösterdiği değeri yani 3 değerini yazdırır.
----

İlk satırda sayi isimli bir değişken tanımladık ve 3 değerini atadık. Daha sonra *pSayi işaretçisini oluşturduk ve değer olarak sayi değişkeninin hafıza adresini atadık. İlk cout ifadesi sayi değişkeninin adresini yazdırır, çünkü pSayi işaretçi değişkeninin tuttuğu değer budur. Fakat son satırdaki çıktı 3 olur. Neden? İşte burada işaretçilerin gücü ve tehlikesi ortaya çıkmaya başlıyor.

Dereference operatörünü kullanarak sayi değişkeninin altında yatan değere doğrudan erişim sağlayabilirsiniz. Eğer hala bunun ne anlama geldiğini anlayamadıysanız, açıklık getirmek için aşağıdaki koda bakalım.

[source,c++]
----
int sayi = 3;
int* pSayi = &sayi;
cout << pSayi << endl;
cout << *pSayi << endl;

*pSayi = 45;
cout << *pSayi << endl;
cout << sayi << endl;
----

Burada açıklanmak istenen dereference operatörünü sayi değişkeninin altında yatan değeri *dolaylı* yoldan değiştirmek için kullandığımızdır. Son iki cout satırı *pSayi ve sayi değerlerinin tam olarak aynı olduğunu göstermektedir. Bu noktada basit bir şekilde doğrudan değişkenin değerini değiştirebilirdik diyebilirsiniz. Bir sonraki konuda işaretçilerin neden kullanıldığına değinilecektir.

==== Neden İşaretçiler?

İşaretçileri kullanmak için sebeplerden biri program performansıdır. Şu ana kadar yaptığımız örneklerde fonksiyonlarda kullanılan veri miktarı oldukça azdı. Fakat eğer bazı sınıf sayfaları gibi daha büyük veri yapıları kullanıyor olsaydık işaretçi kullanmak çok daha verimli olacaktı.

Örnek kodda görüldüğü gibi bir değişkenin referansı alınabildiği gibi işaretçiler bulunduğu değişkenin değerini de değiştirebilir. Bir kez daha, işaretçiler değişkenin altında yatan değere (adrese) doğrudan bir bağlantı sağlar, böylece daha kolay bir şekilde değer değişikliği yapılabilir.

İşaretçiler aynı zamanda hafızadan yer ayırmayı sağlar. Bu özelliğe dizi ve nesne oluştururken ihtiyaç duyabilirsiniz.


=== Referans Tipleri

C{plus}{plus} referans olarak bilinen bir tip içerir. Referans tipi basitçe başka bir tipin kopyasıdır denilebilir. Kodunuzdaki başka bir tipe işaret eder. Referans tipi & operatörünü kullanır. Şu ana kadar & operatörünü bir değişkenin adresini almak için kullanılan adres alma operatörü olarak gördünüz. Referanslar aynı zamanda başka bir değişkene referans ettiğini belirtmek için de kullanılır.

Referans tanımlaması işaretçi tanımlamasıyla benzer bir sözdizimine sahiptir. Referans edilecek veri tipini referansınızın veri tipi olarak belirliyorsunuz, daha sonra & karakterini koyup ismini veriyorsunuz, burada unutulmaması gereken husus referansın oluşturulduğu anda atanması gerektiğidir.  Bu mantıkla sabitler gibi davranır denilebilir. Aşağıdaki örnek tanımlamayı açıklayacaktır.

[source,c++]
----
 int sayi = 3;
 int& refSayi = sayi;
 // int& refSayi2;///Hata: Referans değişkeni oluşturulduğu anda atanmalıdır.
 cout << refSayi << endl;
----

Yukarıdaki kod örneğinde sayi isimli bir integer değişken oluşturduk ve 3 değerini verdik. Sonrasında refSayi adında bir referans tanımladık. (&) işareti bize bunun bir referans değeri olduğunu gösteriyor. Aynı anda sayi değişkenine atadığımıza dikkat edin. Bu refSayi ile sayi'yı birbirine bağlar. Bu referans üzerinde tekrar atama yapmak mümkün değildir.

Kodun 3. satırında bir hata belirecektir çünkü değer atanmamıştır. Son satır ise 3 değerini yazdıracaktır çünkü refSayi, 3 değerini tutan sayi'nın referansıdır.

Referansın sayi değişkeninin orijinal değerini nasıl değiştirdiğini görmek için refSayi üzerinden değişiklik yaparak sayi değişkeninin değerini değiştiren ve bu iki değişkenin hafızadaki adreslerini gösteren kısa bir kod yazalım.

[source,c++]
----
int sayi = 3;
int& refSayi = sayi;

cout << "sayi: " << sayi << endl;
cout << "refSayi: " << refSayi << endl;

refSayi++;///refSayi değeri 1 arttırılır

cout << "sayi: " << sayi << endl;
cout << "refSayi: " << refSayi << endl;

cout << "sayi degiskeninin adresi: " << &sayi << endl;
cout << "refSayi degiskeninin adresi: " << &refSayi << endl;
----

Benim bilgisayarımda kod çıktısı şu şekilde oldu: 

----
sayi: 3
refSayi: 3
sayi: 4
refSayi: 4
sayi degiskeninin adresi: 0x62fe98
refSayi degiskeninin adresi: 0x62fe98
----

İlk iki satır sayi ve refSayi referansını oluşturuyor. İlk iki cout ifadesi sayi ve refSayi değerlerini yazdırıyor ve ikisinin de 3 değerini sakladığını görüyoruz. 5. satırda refSayi değerini 1 arttırıyoruz, bu durumda refSayi'nın sayi değişkeninin referansı olduğundan sayi değeri de 1 artacaktır.

3. ve 4. cout ifadeleri de refSayi değeri gibi sayi değerinin de 4 değerine arttırıldığını gösterir. Son iki satır ise sayi ve refSayi adreslerinin aynı hafıza bölgesine işaret ettiğini gösterir. Sonuç olarak refSayi'da yapılan her değişiklik sayi değişkenini de etkileyecektir.

Referanslar genellikle fonksiyonlara parametre olarak kullanılırlar. Değer parametresi göndermek anlaşıldığı gibi sadece değeri gönderir. Aşağıdaki programda nasıl bir etkisi olduğunu görelim.

[source,c++]
----
using namespace std;

void degerGonder(int);

int main()
{
    int sayi = 3;

    cout << "degerGonder fonksiyonuna girmeden once sayi degeri: " << sayi << endl;

    degerGonder(sayi);

    cout << "degerGonder fonksiyonundan ciktiktan sonra sayi degeri: " << sayi << endl;

    return 0;
}

void degerGonder(int sayi1){

    sayi1++;
    cout << "degerGonder fonksiyonu icerisinde sayi degeri: " << sayi1 << endl;

}
----

Bu kod parçasında main() fonksiyonundan önce bir fonksiyon prototoipi tanımlıyoruz. main() içerisinde sayi değişkeni oluşturup 3 değerini atıyoruz. Fonksiyon içerisine göndermeden önceki sayi değerini yazdırıyoruz.

Daha sonra degerGonder(int sayi1) fonksiyonuna parametre olarak sayi değişkenini gönderiyoruz. 

degerGonder fonksiyonu içerisinde sayi1 değişkeninin değerini bir arttırıp yeni değerini yazdırıyoruz (4).

degerGonder() fonksiyonu tamamlandıktan sonra tekrar main() fonksiyonuna dönüyoruz ve sayi değerini yazdırdığımızda çıktının 4 değil 3 olduğunu görüyoruz.

Değer göndermek sadece gönderilen değişkenin referansından ziyade değerinin kopyasını kullanır. Bu yüzden degerGonder() fonksiyonunda yapılan değişiklikler sadece sayi1 değişkenini etkileyecektir. Eğer fonksiyonumuzda sayi değişkenini değiştirmek isteseydik değer yerine referans göndermemiz gerekirdi. Aşağıdaki kod örneği bu konuyu açıklamaya yardımcı olacaktır.

[source,c++]
----
using namespace std;

void referansGonder(int&);

int main()
{
    int sayi = 3;

    cout << "referansGonder fonksiyonuna girmeden once sayi degeri: " << sayi << endl;

    referansGonder(sayi);

    cout << "referansGonder fonksiyonundan ciktiktan sonra sayi degeri: " << sayi << endl;

    return 0;
}

void referansGonder(int& sayi1){

    sayi1++;
    cout << "referansGonder fonksiyonu icerisinde sayi degeri: " << sayi1 << endl;

}
----

Çıktı: 

----
referansGonder fonksiyonuna girmeden once sayi degeri: 3
referansGonder fonksiyonu icerisinde sayi degeri: 4
referansGonder fonksiyonundan ciktiktan sonra sayi degeri: 4
----

sayi değerini fonksiyona referans olarak gönderdiğimiz için C{plus}{plus} değerin kopyasını oluşturmak yerine adrese erişip değişiklik yapmamıza izin verdi.

=== C{plus}{plus}'da Hafıza Yönetimi

Bilgisayarların sınırlı miktarda fiziksel belleğe sahip olduklarının farkında olmalısınız. İşletim sistemleri hafızayı yönetmekle ve çalışan uygulamalara hafıza ayırmakla sorumludur. Kesin sınırlar içerisinde işletim sistemleri bellek miktarını kontrol edebilir, aynı zamanda daha fazlasına ihtiyaç duyan uygulamalara hafıza sağlamaya çalışır.

Bazı uygulamalar çok fazla hafıza kullanabilir ve bilgisayar performansı açısından sorunlara sebebiyet verebilir.  

Kodunuzdaki her değişken, oluşturduğunuz her nesne, açtığınız her kaynak bilgisayar hafızasının kullanımına ve uygulama performansına etki eder. Oluşturduğunuz int, double, bool gibi nesne olmayan veri tipleri yığın olarak saklanır. Bu değişkenler geçerli tanım alanından çıktığı zaman bu yığındaki bu hafıza alanı tekrar kullanılabilir hale gelir. 

Yönetilmemiş bir kodda maalesef yaygın olarak karşılaşılan olay *hafıza sızıntısıdır*. Bu uygulamada nesne oluşumunun durmaması ve sürekli daha fazla nesne oluşumu için daha fazla bellek alanı istenmesinden kaynaklanır. Bu durumda hafıza tükenecek ve işletim sistemi programı durduracaktır hatta işletim sistemi bile çökebilir.

==== Hafıza Ayırma (Allocation)

Çalışma zamanı sırasında hafızadan yer ayırma işlemi alışılmış bir ihtiyaçtır. Çalışma zamanı sırasında yeni oluşturulan nesnelere hafıza ayırmak için işaretçilerden yararlanılır. Uygulama çalışırken yeni nesneler için hafızaya erişim sağlamanın tek yolu budur.

[source,c++]
----
/// new anahtar kelimesiyle bir integer tipinde işaretçi oluşturulur ve hafızadan yer ayırılır
int* pInt = new int;

/// new anahtar kelimesiyle bir double tipinde işaretçi oluşturulur ve hafızadan yer ayırılır
double* pDouble = new double;

/// ayrılan hafıza alanına 3 değeri eklenir
*pInt = 3;

/// ayrılan hafıza alanına 5.0 değeri eklenir
*pDouble = 5.0;
----

Bu kod örneğinde new anahtar kelimesini kullanılmıştır. Aynı zamandaa eski kod örneklerinden farklı olarak işaretçiye değer ataması yapmadık. Bunun yerine derleyiciye int tipine bir işaretçi oluşturmak istedğimizi söyledik ve int bir değer tutmak için dinamik olarak biraz hafıza ayırmasını istedik. Programı çalıştırmadıkça hangi hafıza adresinde olduğunu bilemeyiz. Aynı şeyi double işaretçi için de yaptık.

pInt ve pDouble'ın işaret ettiği hafıza alanındaki değerleri değiştirmek için dereferans operatörünü kullanırız. 

==== Hafıza Bırakma (Deallocation)

Programınızda her yer ayırışınızda bu hafıza işletim sistemi tarafından korunuyor ve diğer uygulamalar bu adreslere ulaşamıyorlar. Bu güvenlik açısından ve sistem çökmesine karşı önemlidir.

Ama eğer uygulamanızda hafızayı bırakmazsanız işletim sistemi o alanı geri alamayacak ve hafıza sızıntısına sebep olacaktır. Uygulamanız sürekli dinamik olarak hafıza ayırır ve bırakmazsa işletim sistemi açısından sıkıntılar ortaya çıkacaktır.

Ayrılmış bir hafızayı geri bırakmanın en kolay yolu delete anahtar kelimesini kullanmaktır. Aşağıdaki kodda delete kelimesinin kullanımını görebilirsiniz.

[source,c++]
----
/// new anahtar kelimesiyle bir integer tipinde işaretçi oluşturulur ve hafızadan yer ayırılır
int* pInt = new int;

/// new anahtar kelimesiyle bir double tipinde işaretçi oluşturulur ve hafızadan yer ayırılır
double* pDouble = new double;

/// ayrılan hafıza alanına 3 değeri eklenir
*pInt = 3;

/// ayrılan hafıza alanına 5.0 değeri eklenir
*pDouble = 5.0;

delete pInt;
delete pDouble;
----

Uygulamamızdaki her işaretçiyi delete anahtar kelimesiyle işletim sisteminin kullanması için geri verdik ve hafıza sızıntısı sorununa mahal vermemiş olduk.

=== Sınıf Dosyalarını Ayırma

Eğer nesneye yönelik programlamanın özelliklerinden biri kapsülleme ise neden sınıflarımızı ayrı sayfalarda oluşturalım? Eğer sınıflar hakkında her şeyi kapsüllemek istiyorsak neden hepsini bir arada tutmuyoruz?

Kapsüllemenin aynı zamanda veri gizleme olduğunu unutmayın. Arabanızı analog bir şekilde kullandığınızı düşünün. Araba birçok farklı bileşenden oluşan karmaşık bir cihazdır. Arabanızı kullanmak için karmaşıklığını anlamanıza gerek yoktur.

Aynı şekilde, sınıf dosyalarınızı kullanan bir programcı fonksiyonlarınızın ne işe yaradığını anlamak için nasıl implemente ettiğinizi bilmeye ihtiyaç duymaz, eğer kimsenin anlamayacağı şekilde bir algoritma ile şifrelemiyorsanız.

Sınıf dosyaları header ve implementation(uygulama) dosyalarından oluşur.

==== Header Dosyaları

C{plus}{plus}'da sınıflar genellikle iki ayrı dosyada oluşturulur. Header dosyası, .h uzantısına sahiptir, sınıf dosyasındaki tanımlamaları içerir. Tanımlamalar içerisinde fonksiyon prototipleri ve sınıf yapıcı ve yıkıcı fonksiyonları da bulunur. Asıl uygulamanın yapıldığı kod sayfası implementation dosyasında bulunur, .cpp uzantısına sahiptir.

Aşağıdaki örnekte bir sınıf header dosyası oluşturulmuştur.

[source,c++]
----
///dikdortgenPrizma sınıfının header dosyası
///dikdortgenPrizma.h
#pragma once

class dikdortgenPrizma {
private:
    int uzunluk;
    int genislik;
    int derinlik;

public:
    dikdortgenPrizma();
    int getUzunluk() const;
    int getGenislik() const;
    int getDerinlik() const;
    void setUzunluk(int u);
    void setGenislik(int g);
    void setDerinlik(int d);
    int Hacim() const;

};
----

Yukarıdaki kod örneğinde dikdortgenPrizma sınıfı için oluşturulmuş header dosyasını görüyoruz. Yorum satırlarından sonra gelen #pragma once ifadesi derleyiciye programda kaç kere import edilirse edilsin sadece bir kez çağırmasını söyleyecektir.

Daha sonra süslü parantez içerisinde değişken ve fonksiyonlarımızı erişim belirleyicileriyle beraber oluşturuyoruz.

Farkettiyseniz oluşturulan fonksiyonların herhangi bir uygulaması bulunmamakta. Sadece parametre olarak almak istedğimiz değerleri giriyoruz.

Son olarak bahsedilmesi gereken nokta süslü parantezlerden sonra gelen ; işaretidir. Çoğu yeni programcının bunu unutmaya eğilimi vardır. Visual Studio ve bazı yeni IDE'ler bunu otomatik olarak yapıyor.

==== Uygulama (Implementation) Dosyaları

Şimdi de asıl uygulamaların bulunduğu, .cpp uzantısına sahip implementasyon dosyalarına bakalım.

[source,c++]
----
#include "dikdortgenPrizma.h"

dikdortgenPrizma::dikdortgenPrizma() {
    uzunluk = 5;
    derinlik = 5;
    genislik = 5;
}

int dikdortgenPrizma::getGenislik() const {
    return genislik;
}

int dikdortgenPrizma::getUzunluk() const {
    return uzunluk;
}

int dikdortgenPrizma::getDerinlik() const {
    return derinlik;
}

void dikdortgenPrizma::setGenislik(int g) {
    genislik = g;
}

void dikdortgenPrizma::setUzunluk(int u) {
    uzunluk = u;
}

void dikdortgenPrizma::setDerinlik(int d) {
    derinlik = d;
}

int dikdortgenPrizma::Hacim() const {
    return uzunluk*derinlik*genislik;
}
----

Örnekte görüldüğü gibi .h header dosyasında tanımlanan fonksiyonların uygulamaları .cpp implementasyon dosyasında belirtilmiştir. Burada dikkat edilmesi gereken husus fonksiyonların ayrı bir tanım alanında açıklanmasından dolayı fonksiyon isminden önce sınıfının ismi ve "::" operatörü ile belirtilmesi gerektiğidir.


==== Sınıf Yapıcı ve Yıkıcı Fonksiyonları
Yapıcı fonksiyon bir sınıftan yeni bir nesne oluşturulduğunda çalışan özel bir üye fonksiyondur.

Yapıcı fonksiyon sınıfla aynı ismi alır ve herhangi bir değer döndürmez (return ifadesi bulunamaz), void de değildir, yapıcı fonksiyonun başına bir anahtar kelime koyulamaz.

[source,c++]
----
using namespace std;

class Dikdortgen {
   public:
      void setUzunluk( int u );
      int  getUzunluk();
      Dikdortgen();  // Yapıcı fonksiyon

   private:
      int uzunluk;
};

// Yapıcı fonksiyon içinde olmak üzere üye fonksiyonların tanımlamaları
Dikdortgen::Dikdortgen() {
   cout << "Nesne olusturuldu." << endl;
}

void Dikdortgen::setUzunluk( int u ) {
   uzunluk = u;
}

int Dikdortgen::getUzunluk() {
   return uzunluk;
}

int main( ) {
   Dikdortgen nesne1;

   nesne1.setUzunluk(6); 
   cout << "Nesne1 uzunlugu : " << nesne1.getUzunluk() <<endl;

   return 0;
}
----

==== Yıkıcı Fonksiyonlar

Derleyici yıkıcı fonksiyonu uygulama kapatıldığında veya nesnenin süresi dolduğunda çalıştırır. Yıkıcı fonksiyon içerisine kod yazabilirsiniz, bunu yapmak için bir sebep kullanılan her kaynağın temizlendiğinden emin olmak olabilir.

=== Sınıf Tanım Alanı

Bir sınıf içerisinde tüm üye değişkenler ve fonksiyonlar sınıf fonksiyonları tarafından erişilebilirlerdir. Sınıf üyelerinin public, private gibi erişim niteleyicilere sahip olduğunu da unutmayın. Tüm public ve private elemanlara sınıf içerisindeki fonksiyonlar tarafından erişilebilir.

Sınıf elemanını çağırma yönteminin elemanın tipine göre değişeceğini de unutmayın. Mesela static elemanlara ulaşmak için bir tanımlama yapmaya gerek yoktur, sadece . operatörü ile erişim mümkündür.

[source,c++]
----
Insan insan("Gustavus", "Adolphus");
Kurt kurt();

insan.merhaba();
kurt.merhaba();
----

Kurt ve insan isimli iki sınıfımız olduğunu varsayalım ve kurt nesnesinin merhaba() fonksiyonunun "hav", insan nesnesinin merhaba() fonksiyonunun "merhaba" çıktısı verdiğini düşünelim. Insan tipinde bir nesne tanımlayıp merhaba() fonksiyonu çağırdığınızda derleyici hangi merhaba fonksiyonunu çağıracağını anlar ve Insan sınıf tanım aralığı içerisindeki merhaba fonksiyonunu çağırır.

**Insan.h**

[source,c++]
----
#pragma once

#include 
#include <string>
using namespace std;

class Insan {
private:
    string isim;
    string soyIsim;
    int yas;
public:
    Insan();
    Insan(string i, string s);
    Insan(string i, string s, int y);

    ~Insan();

    void merhaba() const;
};
----

**Insan.cpp**

[source,c++]
----
#include "Insan.h"

Insan::Insan() {

}

Insan::Insan(string i, string s) {
    isim = i;
    soyIsim = s;
}

Insan::Insan(string i, string s, int y) {
    isim = i;
    soyIsim = s;
    yas = y;
}

Insan::~Insan() {}

void Insan::merhaba() const{
    cout << "Merhaba" << endl;
}
----

Header ve implementasyon dosyalarında görüldüğü gibi 3 adet private üye değişkenimiz, 3 public yapıcı fonksiyonumuz ve bir adet public fonksiyonumuz var. 

=== Namespaceler

Namespace isim çakışmalarını önlemek amacıyla kullanılır. Özellikle büyük projelerde isim bulmakta zorlanılacağı için namespace kullanılır. Daha önceki örneklerde kullandığımız cout özelliği std namespace'inde bulunur. "::"tanım çözünürlük operatörüdür ve std namespace'indeki cout fonksiyonuna erişmeyi sağlar.

Cout fonksiyonuna sahip olan bir namespace daha oluşturalım.

[source, c++]
----
using namespace std;
using namespsce isimAlani;

int main(){
    cout << "std merhabaDunya";
    cout << "isimAlani merhabaDunya";
}
----

Derleyici hangi namespace'in cout fonksiyonunu çağırdığımızı anlayamayacaktır. Bu durumda şu şekilde yazmak daha doğrudur.

[source, c++]
----
using namespace std;

int main(){
    cout << "std merhabaDunya";
    isimAlani::cout << "isimAlani merhabaDunya";
}
----

namespace anahtar kelimesi ile kendi namespace'inizi oluşturabilirsiniz. Opsiyonel olarak iç içe namespace oluşturma şansınız da vardır. Aşağıdaki örnek bunu göstermektedir.

[source,c++]
----
 namespace isimAlani  
    {  
        namespace Geometri  
        {  
            const double PI = 3.14159;  

            double Alan(double r)  
            {  
                return PI*(r*r);  
            }  
        }  

    }
----

**Using deyimi kullanarak erişim**

[source,c++]
----
using namespace isimAlani;  

    int main()  
    {  

        double yaricap = 12.5;  

        double alan = Geometri::Alan(yaricap);  
    }
----

**Using deyimi kullanmadan erişim**

[source, c++]
----
int main()  
    {  

        double yaricap = 12.5;  

        double area = isimAlani::Geometri::Alan(yaricap);  
    }
----

Kodu basite indirgemek için namespace'ler üzerinde yoğunlaşabiliriz. İlk kod parçasında isimAlani adında bir namespace ve Geometri adında bir iç namespace oluşturduk. Geometri namespace'i içerisinde PI sayısını tanımlamak amaçlı bir sabit ve verilen yarıçap değeriyle çemberin alanını hesaplayacak Alan fonksiyonumuz var. 2. ve 3. kod parçalarında ise bu fonksiyonu kod içerisinde nasıl kullanabildiğimiz gösterilmiştir.

=== Kalıtım

Yeni sınıflar kalıtım mekanizmasıyla var olan sınıflardan türetilebilirler. Sınıfların türetildiği sınıflara ana sınıf ve türetilen sınıflara ise alt sınıf denir.

[source, c++]
----
class Arac
{
private:
    string Mensei;    
    string Renk;
    ...
};

class Araba : Arac
{
    ///Mensei ve Renk özelliklerini içerir
    ///Araba için diğer özellikler burada bulunacaktır
};
----

Bu örnekte Arac ana sınıf, Araba ise türetilmiş sınıftır. Araba sınıfı otomatik olarak Mensei ve Renk özelliklerini kalıtır ve Araba'ya özel özellikleri ve fonksiyonları eklemekte özgürdür.

==== C{plus}{plus}'da Kalıtım Tipleri

C{plus}{plus} public, private ve protected olmak üzere 3 çeşit kalıtım tipini destekler. Public kalıtım'da türetilen sınıf ana sınıfın private ve public tüm üye değişkenlerini kalıtır fakat sadece ana sınıfın public elemanlarına doğrudan erişebilir. 

**Insan.h**

[source,c++]
----
#pragma once

#include 
#include <string>
using namespace std;

class Insan {
private:
    string isim;
    string soyIsim;
    int yas;
public:
    Insan();
    Insan(string i, string s);
    Insan(string i, string s, int y);

    ~Insan();

    void merhaba() const;
};
----


**Ogrenci.h**

[source, c++]
----
#pragma once  
#include "Insan.h"  

class Ogrenci :  public Insan  
{  
public:  
    Ogrenci();  
    ~Ogrenci();  
};  
----

**Ogrenci.cpp**

[source, c++]
----
#include "Ogrenci.h"  

    Ogrenci::Ogrenci()  
    {  
    }  

    Ogrenci::~Ogrenci()  
    {  
    }
----

**main.cpp**

[source, c++]
----
#include "Insan.h"  
#include "Ogrenci.h"  

int main()  
{  

    Ogrenci ogrenci1;  

    //student1.firstName = "Tom";///Hata: private elemana doğrudan erişim  

    student1.merhaba();  

    return 0;  
}
----

Bu örnekte bir Insan sınıfımız var. Daha sonra Ogrenci sınıfı geliyor ve ":" işareti ve public Insan ile devam ediyor. Bu Ogrenci sınıfının Insan sınıfının public kalıtımlı alt sınıfı olduğunu gösteriyor. Aynı zamanda Ogrenci sınıfının varsayılan yapıcı ve yıkıcı fonksiyonları vardır ki bunlar Insan sınıfınınkilerden ayrıdır.

Bahsedildiği gibi C{plus}{plus} kalıtımında public, private ve protected olmak üzere 3 tip vardır.

|====
| public | protected | private
| public üyeler türetilmiş sınıfta da public olur ve üye ve üye olmayan fonksiyonlar tarafından doğrudan erişilebilirler| public üyeler türetilmiş sınıfta protected olurlar ve üye fonksiyonlar tarafından erişilebilirler | public üyeler türetilmiş sınıfta private olurlar ve üye fonksiyonlar tarafından erişilebilirler
| protected üyeler türetilmiş sınıfta da protected olur ve üye fonksiyonlar tarafından erişilebilirler |  üyeler türetilmiş fonksiyonda yine protected olurlar ve üye fonksiyonlar tarafından erişilebilirler | protected üyeler türetilmiş sınıfta private olurlar ve üye fonksiyonlar tarafından erişilebilirler
| private üyeler türetilmiş sınıfta gizlidir ve erişilemezler | private üyeler türetilmiş sınıfta gizlidir ve erişilemezler | private üyeler türetilmiş sınıfta gizlidir ve erişilemezler
|====

=== Protected Erişimi

C{plus}{plus}'da kalıtım ile uğraşırken, bazı elemanların "dış dünyaya" private, türetilmiş sınıflara ise public olarak davranmasının istenebileceği durumlar olabilir. C{plus}{plus} dili bu durum için protected anahtar kelimesini sağlıyor.

Örnek olarak, Insan sınıfını ve türetilmiş sınıf olarak da Ogrenci sınıfını ele alalım. Şu anda elimizde bulunan koda göre Ogrenci sınıfının isim, soyIsim ve yas elemanlarına doğrudan erişimi olmadığını biliyoruz. Doğrudan erişim sağlayabilmek için değişkenleri private yerine protected yapabiliriz.


=== Friend Fonksiyonlar

Bir sınıf harici olarak bir arkadaş fonksiyon tanımlayabilir. Arkadaş fonksiyonun private üyeler dahil olmak üzere tüm üyelere erişmesine izin verilir. Arkadaş fonksiyonlar üye fonksiyon değildirler yani "this" işaretçisine ihtiyaç duymazlar. Ancak nesneye erişmek için parametreye ihtiyaçları vardır.

Aşağıdaki örnek nasıl arkadaş tipinde harici bir fonksiyon oluşturulduğunu göstermektedir. Oluşturulan hariciFonksiyon() kullanılacak nesnenin referansını parametre olarak alır:

**Deneme.h**
[source, c++]
----
class Deneme  
{  
    friend void hariciFonksiyon(Deneme & hedefNesne);  

    // Elemanlar ve fonksiyonlar...  
    ...  
};
----

Arkadaş fonksiyon prototipi yukarıdaki gibi yapılır. Aşağıda ise implementasyon sayfasındaki hali bulunmaktadır. Görüldüğü gibi implementasyon sayfasında friend ön eki tekrar koyulmaz ve Deneme:: ön eki de yazılmaz çünkü harici bir fonksiyondur.

**Deneme.cpp**
[source, c++]
----
#include "Deneme.h"

void hariciFonksiyon(Deneme & hedefNesne)  
    {  
        // hedefNesne üzerinde private dahil olmak üzere her elemana erişilebilir  
        ...  
    }
----

=== Arkadaş Sınıflar

Bir sınıf başka bir sınıfı arkadaşı olarak tanımlayabilir. Arkadaş sınıf diğer sınıfın tüm elemanlarına erişim sağlayabilir.

**sinif1.h**

[source, c++]
----
#pragma once

class sinif1{
    friend class arkadasSinif;
private:
    int gizliDeger = 10;    
};
----

Yukarıdaki kodda sinif1 adında bir sınıf oluşturduk, private bir eleman koyduk ve arkadasSinif adında bir friend sınıfımız olacağını derleyiciye bildirdik.

**arkadasSinif.h**

[source, c++]
----
#pragma once

#include "sinif1.h"

class arkadasSinif{
public:
    arkadasSinif();
    void gizliDegeriDegistir(sinif1 n);    
};
----

**arkadasSinif.cpp**

[source, c++]
----
#include arkadasSinif.h

arkadasSinif::arkadasSinif(){}

void arkadasSinif::gizliDegeriDegistir(sinif1 n){
    n.gizliDeger++;
}
----

Örnekte görüldüğü gibi arkadasSinif sınıfından sinif1 sınıfındaki private elemana erişildi ve üzerinde değişiklik yapıldı.

=== Sanal Fonksiyonlar

Kalıtım özelliğini kullanmanın sebeplerinden biri ilişkili sınıflar arasında hiyerarşi kurmaktır. Örneğin öğrenci, çalışan, yönetici gibi sınıflar varsa bu sınıfların ortak veri elemanlarını insan isimli bir ana sınıfta tutulabilir.

Kalıtım kullanırken türetilmiş sınıfların ana sınıftan üye fonksiyonları kalıtırken daha özelleşmiş fonksiyonlara ihtiyacı olduğunu düşünebilirsiniz. Örneğin Insan sınıfı goster() fonksiyonunda isim ve yasini gösterip türetilmiş Ogrenci sınıfı aynı fonksiyonda bölümünü gösteriyor olabilir. Bu "overriding" olarak geçer.

C{plus}{plus}'da override edilebilir üye fonksiyon oluşturmak için fonksiyonun başına virtual ön eki koyulmalıdır.

[source, c++]
----
class Insan
{
private:
    std::string isim;
    int yas;
    
public:
    virtual void goster() const;///Override edilebilir fonksiyon
    
};
----

Kaynak kodda virtual anahtar kelimesinin kullanılmadığını unutmayın:

[source, c++]
----
void Insan::goster() const{
    std::cout << isim << "," << yas << std::endl;
}
----

==== Sanal Fonksiyonların Override Edilmesi

Türetilmiş bir sınıf oluşturduğunuzda sanal fonksiyonların bazılarını ya da tamamını ana sınıftan override edebilirsiniz. Override yapmak zorunda da değilsiniz.

Türetilmiş sınıfta sanal bir fonksiyonu override etmek için sınıfın header sayfasında fonksiyonu tekrar tanımlamanız gerekir. Fonksiyon yapısı ana sınıftakiyle uyuşmak zorundadır. Override edilebilir bir fonksiyon olduğunu belirtmek için virtual anahtar kelimesini tekrar kullanabilirsiniz.

Aşağıdaki örnek ana sınıftan Ogrenci türetilmiş sınıfına goster() fonksiyonuna override edilmesini gösterir:

[source, c++]
----
class Ogrenci : public Insan  
{  
private:  
    std::string bolum;  

public:  
     virtual void goster() const;     // Ana sınıftan fonksiuon override eder
    ...  
};
----

Türetilmiş sınıfın kaynak kodunda override edilmiş fonksiyonun yeni versiyonu uygulanır. 

[source, c++]
----
void Ogrenci::goster() const{
    std::cout << bolum << std::endl;
}
----

==== Sanal Yıkıcı Fonksiyonlar

Eğer bir ana sınıf bir ya da daha fazla sanal fonksiyon içeriyorsa sanal yıkıcı fonksiyon da tanımlamalıdır. Örneğin Insan sınıfı için sanal yıkıcı tanımı:

[source, c++]
----
class Person  
{  
    ...  
public:  
    virtual ~Person();  
    ...  
};  

Person::~Person()  
{  
    // Insan nesnesi için yıkıcı kodlar.  
}
----

Ana sınıfta sanal yıkıcı fonksiyon tanımlayarak, bir nesneyi sildiğinizde doğru yıkıcının çağırıldığından emin olursunuz.

==== Değiştirilebilirlik İlkesi

Diğer nesneye yönelik programlama dilleriyle benzer olarak C{plus}{plus} ana sınıf tipinde nesne oluşturup bunları türetilmiş sınıflara işaret etmeye izin verir. Belirgin bir şekilde anlatmak gerekirse; X tipindeki bir işaretçi bir X nesnesine ya da X'ten türetilmiş bir nesneye işaret edebilir. Aynı şekilde X tipindeki bir referans değişkeni başka bir X nesnesine veya X'ten türetilmiş bir nesneye referans gösterebilir.

[source, c++]
----
///Ana sınıf işaretçisi aynı tipe veya türetilmiş bir sınıfa işaret edebilir
Insan* i1 = new Insan;
Insan* i2 = new Ogrenci;

///Ana sınıf referans değişkeni aynı tipe veya türetilmiş bir sınıfa referans gösterebilir
Insan& r1 = insanNesnesi;
Insan& r2 = ogrenciNesnesi;
----

Aşağıdaki örnekte işaretçi kullanımını görebilirsiniz:

[source, c++]
----
///Insan tipinde, Ogrenci nesnesine işaret eden bir işaretçi oluşturulur
Insan* i = new Ogrenci;

///Sanal goster() fonksiyonu çağırılır. Burada Ogrenci sınıfının goster() fonksiyonu çağırılacaktır
///çünkü i işaretçisinin işaret ettiği tip budur.
i->goster();
----

Aynısı referans kullanımında da geçerlidir:

[source, c++]
----
///Insan tipinde olup Ogrenci tipinde bir nesneye referans gösteren bir referans değişkeni oluşturulur.
Insan& r = ogrenciNesnesi;

///Sanal goster() fonksiyonu çağırılır. Burada Ogrenci sınıfının goster() fonksiyonu çağırılacaktır
///çünkü r'nin referans gösterdiği tip budur.
r.goster();
----

Bir nesneyi sildiğiniz zaman C{plus}{plus} derleyicisi yıkıcı fonksiyonu çağırır. Eğer yıkıcı fonksiyonu sanal olarak tanımladıysanız, çalışma mekanizması doğru nesne için doğru yıkıcı fonksiyonu çağırır.

[source, c++]
----
Insan* p = new Ogrenci;

///Eğer yıkıcı fonkiyon sanal ise hangi
///yıkıcı fonksiyonun seçileceği bilinir. Bu örnekte
///Ogrenci yıkıcı fonksiyonu çağırılır.
delete p;
----

==== Saf Sanal Fonksiyonlar ve Soyut Sınıflar

Saf sanal fonkiyonlar sanal fonksiyonlarla aynı mantıkta çalışır fakat aralarında bir kaç farklılık bulunmaktadır. Öncelikle saf sanal fonksiyon tanımlamasının nasıl olduğuna bakalım: 

[source, c++]
----
class Insan
{
private:
    std::string isim;
    int yas;
    
public:
    virtual void goster() const = 0; ///Saf sanal fonksiyon bu şekilde tanımlanır.
    
};
----

Saf sanal fonksiyon tanımlandığı yerde gövdeye sahip olamaz yani sadece türetilmek için oluşturulur. Ayrıca saf sanal fonksiyona sahip bir ana sınıftan türetilen her sınıf bu fonksiyonu *kullanmak zorundadır*.

Soyut sınıf kavramı ise tüm fonksiyonları saf sanal fonksiyon olan sınıflar için kullanılır. Saf sanal fonksiyonu override etmemiş türetilmiş sınıflar *soyut sınıf olmak zorundadır* yani sadece saf sanal fonksiyon tanımlamalarından oluşmalıdır.

=== Giriş/Çıkış Akışları (I/O Streams)

Giriş ve çıkış fonksiyonları C{plus}{plus} dilinin özünde bulunmaz, C{plus}{plus} standart kütüphanesiyle beraber sağlanır (std namespace'i). Daha önceki örneklerde cin ve cout nesneleriyle temel giriş/çıkış yapmak için iostream kütüphanesini kullandık. Bu derste iostream kütüphanesini biraz daha detaylı olarak inceleyeceğiz.

=== Akışlar

Temeline bakılırsa C{plus}{plus} dilindeki giriş/çıkış akışlar ile uygulanmıştır. Akış sıralı olarak erişilebilen karakterler dizisidir denilebilir.

Sıklıkla iki farklı akışla uğraşacağız. Giriş akışları klavye, dosya veya ağ gibi veri üreticileri tarafından üretilen girdileri saklamak için kullanılır. Örneğin, kullanıcı program girdi beklemiyorken klavyenin bir tuşuna basabilir. Kullanıcının gönderdiği veri yok sayılmaz, veri giriş akışına koyulur ve program bunu kullanmak için hazır olana kadar bekler.

Bunun tersine çıkış akışları monitör, dosya veya yazıcı gibi belirli veri tüketicileri için çıktı tutar. Bir çıktı cihazına veri yazarken cihaz henüz veriyi kabul etmek için hazır olmayabilir. Örneğin, program çıkış akışına veri yazarken yazıcı çalışmaya hazırlanıyor olabilir. Bu durumda çıkış akışındaki veri onu alana kadar bekleyecektir.

Dosyalar ve ağ gibi cihazlar hem giriş hem de çıkış kaynaklarını kullanabilirler.

==== istream ve ostream

istream ve ostream aslında sınıf değildir. basic_istream ve basic_ostream template sınıflarının typedef tanımlarıdırlar.

typedef basic_istream<char> istream;
typedef basic-ostream<char> ostream;

basic_istream sınıfı değer girişi için >> operatörünü kullanır. Aşağıdaki örnek farklı tiplerde nasıl değer girişi yapıldığı gösterilmektedir:

[source, c++]
----
short s;
std::cin >>s;

int i;  
std::cin >> i;  

long l;  
std::cin >> l;  

unsigned short us;  
std::cin >> us;  

unsigned int ui;  
std::cin >> ui;  

unsigned long ul;  
std::cin >> ul;  

float f;  
std::cin >> f;  

double d;  
std::cin >> d;  

long double ld;  
std::cin >> ld;  

bool b;  
std::cin >> b;  // 0 veya 1 değeri girilmelidir

void * ptr;  
std::cin >> ptr;  // Adres değeri girebilirsiniz, örneğin; FFFF
----

Benzer durum basic_ostream sınıfı için de geçerlidir. basic_ostream değer çıktısı vermek için << operatörünü kullanır.

[source, c++]
----
std::cout  
    << s   << std::endl  
    << i   << std::endl  
    << l   << std::endl  
    << ui  << std::endl  
    << ul  << std::endl  
    << f   << std::endl  
    << d   << std::endl  
    << ld  << std::endl  
    << b   << std::endl  
    << ptr << std::endl;
----

==== String Giriş Çıkışları

std::string sınıfı <string> header dosyasında tanımlıdır ve << ve >> operatörleri ile bir akışa/akıştan giriş ve çıkış almayı sağlar. Örnek olarak:

[source,c++]
----
#include <iostream>  
#include <string>  

int main(){
std::string s;  
cin >> s;  
cout << "Your string is " << s << std::endl;
return 0;
}
----

>> operatörünün tek kelime aldığını unutmayın, ilk boşluk karakterinde durur. Eğer bir metin satırını almak istiyorsanız, std::getline() fonksiyonunu kullanmalısınız. Bu fonksiyon iki parametre alır:

* Giriş akışı

* std::string nesnesi, değeri saklamak istediğiniz yer

[source, c++]
----
std::string isim;
stdi::cout << "Isim soyisim: ";
std::getline(std::cin,isim);
----

==== Özel Sınıf Oluşumunu Desteklemek İçin Akışların Genişletilmesi

istream ve ostream sınıfları tüm temel tipler için giriş çıkışı destekler fakat açık olarak kendi özel sınıflarınızı destekleyemeyecektir. Örneğin bir nokta sınıfı tanımlarsanız, otomatik olarak nokta nesnelerini akışa giriş çıkış yapamazsınız. Aşağıdaki kodda derleyici hatalar verecektir:

[source, c++]
----
class nokta {...};
nokta n1;
std::cin >> n1;//Hata: nokta için >> operatör fonksiyonu yok
std::cout << n1; //Hata: nokta için << operatör fonksiyonu yok
----

Özel oluşturulmuş sınıflarda giriş çıkış desteği sağlamak için özel operator>> ve operator>> tanımlamaları yapmak mümkündür. 

[source, c++]
----
class nokta{
public:
    int x, y;
    
};
----

Bu sınıfa aşağıdaki şekilde özel operator>> tanımlayabilirsiniz: 

[source, c++]
----
std::istream & operator>>(std::istream & is, nokta & n)
{
    is>>n.x>>n.y;
    return is;
}
----

Aşağıdaki hususlara dikkat edin:

* Fonksiyon ismi operator>> olmalıdır. Bu C{plus}{plus}'da operatör overloading'tir öyle ki oluşturduğunuz tipleri standart operatörler tarafından desteklenebilir hale getirip genişletmenizi sağlar.

* Fonksiyon 2 parametre almalıdır. Bunlardan birincisi giriş akışı olacağını tanıtan std::istream referansı olmalıdır. İkinci parametre ise hangi sınıfın bu giriş akışını kullanacağını belirten nokta sınıfı referansı olmalıdır.

* Normal kodda std::cin'i kullandığımız gibi bu fonksiyonun içerisinde de istream nesnesini kullanacağız. Özel olarak x ve y integer değerlerini ayrı ayrı alıyoruz. 

* Fonksiyon referans olarak std::istream nesnesini döndürmelidir. Bu >> operatörünün art arda kullanılmasına izin verecektir. Örneğin kullanıcıdan iki nokta nesnesi girmesi istenebilir:

[source, c++]
----
nokta n1, n2;
std::cout << "İki nokta giriniz: ";
std::cin >> n1 >> n2;
----

Benzer şekilde operator<< fonksiyonu da tanımlayabilirsiniz: 

[source, c++]
----
std::ostream & operator<< (std::ostream & os, const nokta & n){
    os << "[" << n.x << "," << n.y << "]";
    return os;
}
----

Aşağıdaki hususlara dikkat edin:

* Fonksiyon ismi operator<< olmalıdır.

* Fonksiyon iki parametre almalıdır. Birincisi, çıkış akışı olacağını tanıtan std::ostream referansı olmalıdır. İkinci parametre ise hangi sınıfın bu çıkış akışını kullanacağını belirten nokta sınıfı referansı olmalıdır.

* Fonksiyon içerisinde ostream'i aynı std::cout gibi kullandık. Noktaları özel olarak [x,y] formatında yazdık.

* Fonksiyon dönüş değeri olarak std::ostream referansını döndürmelidir. Bu << operatörünün art arda kullanılabilmesini sağlayacaktır.

[source, c++]
----
std::cout << "Noktalar: " << n1 << std::endl << n2 << std::endl;
----

==== Manipülatörler

Manipülatörleri kullanarak akış biçimlendirme yapabilirsiniz. Manipülatörler istenilen biçimlendirmeyi yapmak için akışa verilen ön tanımlı nesnelerdir. Manipülatörlere verilecek en basit örnek akışa "\n" karakteri ekleyen std::endl manipülatörüdür:

[source, c++]
----
std::cout << "Merhaba Dunya" << std::endl;
----

std::endl ve std::flush gibi manipülatörler parametre almazlar ve <iostream> header dosyasında tanımlıdırlar. Parametre alan başka manipülatörler de vardır ve <iomanip> header dosyasında tanımlıdırlar. Örnek olarak std::setw manipülatörü parametre verilen değeri akışın minimum genişliği yapar. 

[source, c++]
----
#include <iomanip> // Parametreli manipülatörleri kullanmak için gereklidir
#include <iostream> //Genel giriş çıkış akış tanımları için gereklidir

int main(){
    std::cout << std::setw(10) << -123.45 << std::endl;
    return 0;
}
----

=== Dosya İşleme

Standart C{plus}{plus} kütüphanesi << ve >> akış operatörleriyle veri yazıp okumayı sağlayan 3 akış temelli sınıf tanımlar. Bu sınıflar <fstream> header dosyasında tanımlıdır:

* std::ifstream std::istream'den kalıtım alır ve >> operatörü ile dosyadan okuma yapmayı sağlar.

* std::ofstream std::ostream'den kalıtım alır ve << operatörü ile dosyaya veri yazdırmayı sağlar.

* std::fstream ise hem std::istream'den hem de std::ostream'den kalıtım alır ve << ve >> operatörleri ile dosyadan veri yazıp okumayı sağlar.

Her dosya akış nesnesinin dosya açmak için parametre olarak dosya adı alan open() metodu vardır. Aynı şekilde dosyayı kapatmak için close() metodu vardır.

[source, c++]
----
#include <fstream>

void dosyaAcipKapatma(){
    //Akış objelerinin tanımlanması(dosyalar henüz açılmadı).
    std::ofstream of;
    std::ifstream if;
    std::fstream iof;
    
    //Dosyaların açılması
    of.open("dosya1.txt");//dosya1.txt dosyasını yazmak için açar
    if.open("dosya2.txt");//dosya2.txt dosyasını okumak için açar
    iof.open("dosya3.txt")//dosya3.txt dosyasını okumak/yazmak için açar
    
    //Dosyaların kapatılması
    of.close();
    if.close();
    iof.close();
}
----

Dosya açmak/kapatmak için dosya akış nesnesinin yapıcı ve yıkıcı fonksiyonlarını da kullanabilirsiniz. Özellikle dosya ismini yapıcı fonksiyona parametre olarak gönderirseniz dosya anında açılacaktır. Aynı şekilde yıkıcı fonksiyon çağırıldığında dosya hala açıksa yıkıcı fonksiyon dosyayı kapatacaktır.

[source, c++]
----
#include <fstream>

void dosyaAcipKapatma(){
    //Dosya akış nesnelerinin tanımlaması(dosyalar yapıcı ile açılır)
    std::ofstream of("dosya1.txt");
    std::ifstream if("dosya2.txt");
    std::fstream iof("dosya3.txt");
}
----

==== Dosya Açma Yöntemleri

Akış yapıcı fonksiyonuyla ya da open() metoduyla dosya açarken isteğe bağlı olarak yöntem parametresi de ekleyebilirsiniz. Yöntem aşağıdaki özelliklerin kombinasyonundan oluşur:

* std::ios_base::in

* Dosyanın giriş operasyonları için açıldığını tanımlar. std::ifstream nesneleri için varsayılan moddur.

* std::ios_base::out

* Dosyanın çıkış operasyonları için açıldığını tanımlar. std::ofstream nesneleri için varsayılan moddur.

* std::ios_base::ate

*  Okuma/yazma işlemlerinin dosyanın sonundan başladığını tanımlar. Varsayılan pozisyon dosyanın başıdır.


Bu özellikleri "|" (VEYA) operatörü ile birleştirebilirsiniz. 